[
    {
        "id": "q1",
        "text": "Quel est l'objectif principal d'une signature host-based ?",
        "options": [
            { "id": "a", "label": "Identifier un logiciel malveillant en analysant le trafic réseau.", "correct": false },
            { "id": "b", "label": "Identifier des fichiers ou clés de registre sur le système infecté.", "correct": true },
            { "id": "c", "label": "Empêcher l'exécution du malware en temps réel.", "correct": false },
            { "id": "d", "label": "Créer une empreinte MD5 du fichier.", "correct": false }
        ],
        "explanation": "Les signatures basées sur l'hôte (host-based) servent à identifier les fichiers ou les clés de registre sur le système de la victime qui montrent des signes d'une infection."
    },
    {
        "id": "q2",
        "text": "Quelle technique consiste à étudier le malware sans l'exécuter ?",
        "options": [
            { "id": "a", "label": "Analyse dynamique", "correct": false },
            { "id": "b", "label": "Analyse comportementale", "correct": false },
            { "id": "c", "label": "Analyse statique", "correct": true },
            { "id": "d", "label": "Analyse mémoire", "correct": false }
        ],
        "explanation": "L'analyse statique consiste à étudier le code ou la structure du malware sans le lancer."
    },
    {
        "id": "q3",
        "text": "Quel outil est principalement utilisé pour l'analyse statique avancée (désassemblage) ?",
        "options": [
            { "id": "a", "label": "Wireshark", "correct": false },
            { "id": "b", "label": "ProcMon", "correct": false },
            { "id": "c", "label": "IDA", "correct": true },
            { "id": "d", "label": "RegShot", "correct": false }
        ],
        "explanation": "IDA est un désassembleur puissant utilisé pour voir le code du malware (en assembleur) avant son exécution."
    },
    {
        "id": "q4",
        "text": "Quelle est la différence majeure entre un ver et un virus ?",
        "options": [
            { "id": "a", "label": "Le ver peut se copier et infecter d'autres machines de manière autonome.", "correct": true },
            { "id": "b", "label": "Le virus ne peut pas être détecté par un antivirus.", "correct": false },
            { "id": "c", "label": "Le ver chiffre les fichiers alors que le virus les efface.", "correct": false },
            { "id": "d", "label": "Il n'y a aucune différence technique.", "correct": false }
        ],
        "explanation": "La distinction principale est que le ver a la capacité de se copier lui-même et d'infecter d'autres machines sans intervention humaine."
    },
    {
        "id": "q5",
        "text": "Que fait un rootkit ?",
        "options": [
            { "id": "a", "label": "Il chiffre les données de l'utilisateur contre une rançon.", "correct": false },
            { "id": "b", "label": "Il cache l'existence d'autres programmes malicieux.", "correct": true },
            { "id": "c", "label": "Il enregistre les frappes au clavier.", "correct": false },
            { "id": "d", "label": "Il lance des attaques DDoS.", "correct": false }
        ],
        "explanation": "Le but d'un rootkit est de dissimuler sa présence ou celle d'autres malwares (comme une backdoor) pour éviter la détection."
    },
    {
        "id": "q6",
        "text": "Quelle est une limite majeure de l'utilisation des hashs pour identifier un malware ?",
        "options": [
            { "id": "a", "label": "Le hash change si l'attaquant modifie un seul bit du fichier.", "correct": true },
            { "id": "b", "label": "Le calcul du hash est trop lent.", "correct": false },
            { "id": "c", "label": "Les hashs ne fonctionnent que sur les fichiers .exe.", "correct": false },
            { "id": "d", "label": "Le hash révèle le code source du malware.", "correct": false }
        ],
        "explanation": "Bien que le hash soit une empreinte digitale unique, il suffit de changer un seul bit dans le fichier pour que le hash change totalement, rendant la détection par hash inefficace contre le polymorphisme."
    },
    {
        "id": "q7",
        "text": "Lors de l'analyse des chaînes de caractères, quel caractère termine une chaîne ?",
        "options": [
            { "id": "a", "label": "0xFF", "correct": false },
            { "id": "b", "label": "0x00 (Null)", "correct": true },
            { "id": "c", "label": "0x0A (Line Feed)", "correct": false },
            { "id": "d", "label": "0x20 (Space)", "correct": false }
        ],
        "explanation": "Les chaînes de caractères dans le code binaire se terminent par le caractère nul (0x00)."
    },
    {
        "id": "q8",
        "text": "Quelle est la différence entre le format ASCII et Unicode pour les chaînes de caractères ?",
        "options": [
            { "id": "a", "label": "ASCII utilise 2 octets, Unicode 1 octet.", "correct": false },
            { "id": "b", "label": "ASCII utilise 1 octet, Unicode 2 octets.", "correct": true },
            { "id": "c", "label": "Unicode ne peut pas être lu par les outils d'analyse.", "correct": false },
            { "id": "d", "label": "ASCII est obsolète et n'est plus utilisé.", "correct": false }
        ],
        "explanation": "En ASCII, chaque caractère occupe 1 octet, alors qu'en Unicode, ils occupent souvent 2 octets, ce qui change la façon dont ils apparaissent en hexadécimal (ex: 42 00 41 00)."
    },
    {
        "id": "q9",
        "text": "Qu'est-ce que le packing d'un malware ?",
        "options": [
            { "id": "a", "label": "L'envoi du malware par email.", "correct": false },
            { "id": "b", "label": "La division du malware en plusieurs fichiers.", "correct": false },
            { "id": "c", "label": "La compression ou le chiffrement du fichier pour dissimuler le code.", "correct": true },
            { "id": "d", "label": "L'installation du malware dans le registre.", "correct": false }
        ],
        "explanation": "Le packing consiste à compresser ou chiffrer l'exécutable pour cacher le code malveillant aux analystes et antivirus. Un 'wrapper' décompresse le code en RAM à l'exécution."
    },
    {
        "id": "q10",
        "text": "Dans l'en-tête PE, comment peut-on repérer un exécutable packé en comparant les tailles ?",
        "options": [
            { "id": "a", "label": "La taille sur le disque (Raw Data) est beaucoup plus grande que la taille en RAM (Virtual Size).", "correct": false },
            { "id": "b", "label": "La taille sur le disque est égale à la taille en RAM.", "correct": false },
            { "id": "c", "label": "La taille sur le disque (Raw Data) est beaucoup plus petite que la taille en RAM (Virtual Size).", "correct": true },
            { "id": "d", "label": "La section .text est vide.", "correct": false }
        ],
        "explanation": "Si l'.exe est packé, le code est compressé sur le disque (petite taille) mais prendra beaucoup de place une fois décompressé en RAM (grande taille)."
    },
    {
        "id": "q11",
        "text": "Quel outil permet de visualiser les dépendances et les fonctions importées (DLL) d'un exécutable ?",
        "options": [
            { "id": "a", "label": "Dependency Walker", "correct": true },
            { "id": "b", "label": "Wireshark", "correct": false },
            { "id": "c", "label": "RegShot", "correct": false },
            { "id": "d", "label": "Resource Hacker", "correct": false }
        ],
        "explanation": "Dependency Walker est utilisé pour lister les DLLs et les fonctions importées/exportées, ce qui donne des indices sur les capacités du programme."
    },
    {
        "id": "q12",
        "text": "Quel type de liaison (linking) est couramment utilisé par les malwares pour charger des bibliothèques uniquement lorsque nécessaire ?",
        "options": [
            { "id": "a", "label": "Liaison statique (Static linking)", "correct": false },
            { "id": "b", "label": "Liaison à l'exécution (Runtime linking)", "correct": true },
            { "id": "c", "label": "Liaison dynamique classique", "correct": false },
            { "id": "d", "label": "Liaison matérielle", "correct": false }
        ],
        "explanation": "La liaison à l'exécution permet au malware de se connecter aux bibliothèques seulement au moment où il en a besoin, souvent pour masquer ses intentions."
    },
    {
        "id": "q13",
        "text": "Quel est l'inconvénient principal de l'analyse dynamique sur une machine réelle ?",
        "options": [
            { "id": "a", "label": "Le malware peut détecter la machine virtuelle.", "correct": false },
            { "id": "b", "label": "Il est difficile de nettoyer l'infection après l'analyse.", "correct": true },
            { "id": "c", "label": "On ne peut pas utiliser d'outils de débogage.", "correct": false },
            { "id": "d", "label": "C'est plus lent qu'une machine virtuelle.", "correct": false }
        ],
        "explanation": "Sur une machine réelle, une fois infectée, il est difficile de garantir que le malware est totalement supprimé, nécessitant souvent la réinstallation de l'OS."
    },
    {
        "id": "q14",
        "text": "Qu'est-ce qu'une sandbox dans le contexte de l'analyse de malware ?",
        "options": [
            { "id": "a", "label": "Un outil pour désassembler le code.", "correct": false },
            { "id": "b", "label": "Un environnement virtuel automatisé qui simule des services réseaux pour observer le comportement.", "correct": true },
            { "id": "c", "label": "Un type de malware qui creuse dans le système.", "correct": false },
            { "id": "d", "label": "Une méthode pour cracker les mots de passe.", "correct": false }
        ],
        "explanation": "Une sandbox (comme Norman Sandbox ou Cuckoo) émule un environnement pour exécuter le malware en sécurité et produire un rapport sur son comportement."
    },
    {
        "id": "q15",
        "text": "Comment exécute-t-on une DLL qui ne peut pas être lancée directement comme un .exe ?",
        "options": [
            { "id": "a", "label": "En la renommant en .exe.", "correct": false },
            { "id": "b", "label": "En utilisant l'outil rundll32.exe.", "correct": true },
            { "id": "c", "label": "En double-cliquant dessus.", "correct": false },
            { "id": "d", "label": "C'est impossible d'exécuter une DLL.", "correct": false }
        ],
        "explanation": "L'outil Windows rundll32.exe permet de charger et d'exécuter des fonctions exportées par une DLL."
    },
    {
        "id": "q16",
        "text": "À quoi sert l'outil RegShot ?",
        "options": [
            { "id": "a", "label": "À prendre des captures d'écran du bureau.", "correct": false },
            { "id": "b", "label": "À comparer l'état du registre avant et après l'exécution d'un malware.", "correct": true },
            { "id": "c", "label": "À modifier les clés de registre en temps réel.", "correct": false },
            { "id": "d", "label": "À analyser le trafic réseau.", "correct": false }
        ],
        "explanation": "RegShot prend un instantané du registre avant et après l'infection, puis compare les deux pour montrer les modifications apportées par le malware."
    },
    {
        "id": "q17",
        "text": "Dans Process Explorer, que peut indiquer une différence importante entre les chaînes de caractères de l'image disque et celles en mémoire ?",
        "options": [
            { "id": "a", "label": "Une erreur de lecture du disque.", "correct": false },
            { "id": "b", "label": "Un remplacement de processus (Process Replacement).", "correct": true },
            { "id": "c", "label": "Que le programme est écrit en Java.", "correct": false },
            { "id": "d", "label": "Rien de particulier, c'est normal.", "correct": false }
        ],
        "explanation": "Si les strings en mémoire sont très différentes de celles sur le disque, cela suggère que l'exécutable en mémoire a été remplacé ou modifié dynamiquement par un malware."
    },
    {
        "id": "q18",
        "text": "Quel est le rôle de l'outil INetSim ?",
        "options": [
            { "id": "a", "label": "Scanner les ports d'une machine distante.", "correct": false },
            { "id": "b", "label": "Simuler des services internet pour tromper le malware.", "correct": true },
            { "id": "c", "label": "Télécharger des malwares depuis internet.", "correct": false },
            { "id": "d", "label": "Créer un botnet.", "correct": false }
        ],
        "explanation": "INetSim simule un environnement internet complet (DNS, HTTP, SMTP) pour analyser le comportement réseau du malware sans lui donner un véritable accès au web."
    },
    {
        "id": "q19",
        "text": "Dans l'architecture x86, quelle convention 'endian' est utilisée ?",
        "options": [
            { "id": "a", "label": "Little-endian (LSB à gauche).", "correct": true },
            { "id": "b", "label": "Big-endian (MSB à gauche).", "correct": false },
            { "id": "c", "label": "Middle-endian.", "correct": false },
            { "id": "d", "label": "No-endian.", "correct": false }
        ],
        "explanation": "Les programmes x86 utilisent le format Little-endian, où l'octet de poids faible est stocké à l'adresse la plus basse (ex: 0x42 devient 42 00 00 00)."
    },
    {
        "id": "q20",
        "text": "Comment l'adresse IP 127.0.0.1 (0x7F000001) est-elle stockée dans la RAM (Little-endian) ?",
        "options": [
            { "id": "a", "label": "7F 00 00 01", "correct": false },
            { "id": "b", "label": "01 00 00 7F", "correct": true },
            { "id": "c", "label": "00 00 00 00", "correct": false },
            { "id": "d", "label": "12 70 00 01", "correct": false }
        ],
        "explanation": "En Little-endian, l'ordre des octets est inversé par rapport à l'écriture hexadécimale standard."
    },
    {
        "id": "q21",
        "text": "Quelle instruction assembleur correspond à 'JZ' ?",
        "options": [
            { "id": "a", "label": "Jump if Zero.", "correct": true },
            { "id": "b", "label": "Jump if Not Zero.", "correct": false },
            { "id": "c", "label": "Jump if Overflow.", "correct": false },
            { "id": "d", "label": "Jump if Sign.", "correct": false }
        ],
        "explanation": "JZ signifie Jump if Zero, ce qui se produit lorsque le Zero Flag (ZF) est défini à 1 (souvent après une comparaison d'égalité)."
    },
    {
        "id": "q22",
        "text": "Que fait l'instruction NOP (opcode 0x90) ?",
        "options": [
            { "id": "a", "label": "Elle arrête le processeur.", "correct": false },
            { "id": "b", "label": "Elle ne fait rien et passe à l'instruction suivante.", "correct": true },
            { "id": "c", "label": "Elle efface la mémoire.", "correct": false },
            { "id": "d", "label": "Elle provoque une erreur.", "correct": false }
        ],
        "explanation": "NOP (No Operation) ne fait rien. Elle est souvent utilisée pour le 'NOP Sled' dans les exploits de buffer overflow."
    },
    {
        "id": "q23",
        "text": "Quel registre contient l'adresse de la prochaine instruction à exécuter ?",
        "options": [
            { "id": "a", "label": "EAX", "correct": false },
            { "id": "b", "label": "ESP", "correct": false },
            { "id": "c", "label": "EBP", "correct": false },
            { "id": "d", "label": "EIP", "correct": true }
        ],
        "explanation": "EIP (Extended Instruction Pointer) pointe vers l'adresse mémoire de la prochaine instruction que le processeur va exécuter."
    },
    {
        "id": "q24",
        "text": "Quelle est la différence entre un debugger 'user mode' et 'kernel mode' ?",
        "options": [
            { "id": "a", "label": "Le user mode nécessite deux PC.", "correct": false },
            { "id": "b", "label": "Le kernel mode ne peut pas déboguer les drivers.", "correct": false },
            { "id": "c", "label": "Le user mode débogue un seul exécutable isolé, le kernel mode débogue le noyau du système.", "correct": true },
            { "id": "d", "label": "Il n'y a pas de différence.", "correct": false }
        ],
        "explanation": "Le debugger user mode (comme OllyDbg) s'exécute au même niveau que l'application, tandis que le kernel mode (comme WinDbg) permet d'interagir avec le noyau et nécessite souvent une configuration plus complexe."
    },
    {
        "id": "q25",
        "text": "Quelle touche faut-il éviter d'utiliser en mode debug kernel pour ne pas causer un écran bleu ?",
        "options": [
            { "id": "a", "label": "Echap", "correct": false },
            { "id": "b", "label": "Impr.écran", "correct": true },
            { "id": "c", "label": "F5", "correct": false },
            { "id": "d", "label": "Ctrl+C", "correct": false }
        ],
        "explanation": "La touche Impr.écran provoque un bug connu (écran bleu) en mode debug kernel, il est recommandé d'utiliser Shift+Impr.écran."
    },
    {
        "id": "q26",
        "text": "Dans un debugger, que fait la commande 'Step-Over' ?",
        "options": [
            { "id": "a", "label": "Elle entre dans le détail de chaque fonction appelée.", "correct": false },
            { "id": "b", "label": "Elle exécute l'instruction et exécute les appels de fonction en une seule fois sans s'y arrêter.", "correct": true },
            { "id": "c", "label": "Elle redémarre le programme.", "correct": false },
            { "id": "d", "label": "Elle ignore l'instruction actuelle.", "correct": false }
        ],
        "explanation": "Step-Over permet de passer à l'instruction suivante dans le code actuel. Si l'instruction est un CALL, la fonction appelée est exécutée entièrement sans que le debugger ne s'arrête à l'intérieur."
    },
    {
        "id": "q27",
        "text": "Comment fonctionne un breakpoint logiciel ?",
        "options": [
            { "id": "a", "label": "Il utilise les registres de debug DR0-DR3.", "correct": false },
            { "id": "b", "label": "Il remplace le premier octet de l'instruction par 0xCC.", "correct": true },
            { "id": "c", "label": "Il arrête le ventilateur du CPU.", "correct": false },
            { "id": "d", "label": "Il désactive la carte réseau.", "correct": false }
        ],
        "explanation": "Le debugger remplace l'octet de l'instruction par 0xCC, qui déclenche une interruption (INT 3) pour redonner la main au debugger."
    },
    {
        "id": "q28",
        "text": "Quel est l'avantage principal d'un breakpoint matériel ?",
        "options": [
            { "id": "a", "label": "Il ne modifie pas le code en mémoire, ce qui le rend plus difficile à détecter.", "correct": true },
            { "id": "b", "label": "Il permet de mettre un nombre illimité de points d'arrêt.", "correct": false },
            { "id": "c", "label": "Il est plus lent que le breakpoint logiciel.", "correct": false },
            { "id": "d", "label": "Il fonctionne même si le PC est éteint.", "correct": false }
        ],
        "explanation": "Contrairement au breakpoint logiciel qui modifie le code (0xCC), le matériel utilise les registres du CPU, évitant ainsi la détection par vérification d'intégrité du code."
    },
    {
        "id": "q29",
        "text": "Que signifie une exception de seconde chance dans un debugger ?",
        "options": [
            { "id": "a", "label": "Le programme a géré l'exception correctement.", "correct": false },
            { "id": "b", "label": "Le debugger a ignoré la première exception.", "correct": false },
            { "id": "c", "label": "L'application n'a pas géré l'exception.", "correct": true },
            { "id": "d", "label": "C'est une exception réservée au noyau.", "correct": false }
        ],
        "explanation": "La seconde chance signifie que le programme n'a pas pu résoudre le problème (exception) par lui-même. C'est souvent un signe important lors de l'analyse (crash ou anti-debug). Le programme aurait planté sans le debugger."
    },
    {
        "id": "q30",
        "text": "Pourquoi modifierait-on la valeur du registre EIP (ou RIP) manuellement dans un debugger ?",
        "options": [
            { "id": "a", "label": "Pour changer la couleur du debugger.", "correct": false },
            { "id": "b", "label": "Pour sauter une fonction ou modifier le flux d'exécution du programme.", "correct": true },
            { "id": "c", "label": "Pour augmenter la vitesse du processeur.", "correct": false },
            { "id": "d", "label": "Pour sauvegarder le fichier.", "correct": false }
        ],
        "explanation": "Changer l'EIP permet de rediriger l'exécution, par exemple pour sauter une instruction malveillante ou une vérification de sécurité."
    },
    {
        "id": "q32",
        "text": "Quelle est la règle générale n°1 de l'analyse de malware selon le cours ?",
        "options": [
            { "id": "a", "label": "Il faut absolument comprendre 100% du code.", "correct": false },
            { "id": "b", "label": "Ne pas perdre de temps à tout comprendre, se concentrer sur l'essentiel.", "correct": true },
            { "id": "c", "label": "Toujours utiliser Linux.", "correct": false },
            { "id": "d", "label": "Ne jamais utiliser de machine virtuelle.", "correct": false }
        ],
        "explanation": "Le cours précise qu'il est inutile de passer '1000 ans' à tout comprendre ; il faut se concentrer sur les fonctionnalités importantes."
    },
    {
        "id": "q33",
        "text": "Quel outil permet d'écouter un port TCP ?",
        "options": [
            { "id": "a", "label": "Ncat", "correct": true },
            { "id": "b", "label": "Notepad++", "correct": false },
            { "id": "c", "label": "PEID", "correct": false },
            { "id": "d", "label": "Hashcalc", "correct": false }
        ],
        "explanation": "Ncat permet d'écouter des ports et d'interagir avec les connexions réseau, utile pour voir ce que le malware envoie."
    },
    {
        "id": "q34",
        "text": "Qu'est-ce que l'obfuscation ?",
        "options": [
            { "id": "a", "label": "L'action de rendre le code difficile à lire pour les humains et les outils d'analyse.", "correct": true },
            { "id": "b", "label": "L'action de supprimer le code source.", "correct": false },
            { "id": "c", "label": "L'action de rendre le code plus rapide.", "correct": false },
            { "id": "d", "label": "L'action de commenter le code.", "correct": false }
        ],
        "explanation": "L'obfuscation vise à complexifier l'analyse statique en rendant le code confus ou caché."
    },
    {
        "id": "q35",
        "text": "Quel outil graphique Windows permet de visualiser les chaînes de caractères ?",
        "options": [
            { "id": "a", "label": "BinText", "correct": true },
            { "id": "b", "label": "Cmd.exe", "correct": false },
            { "id": "c", "label": "Paint", "correct": false },
            { "id": "d", "label": "Calculatrice", "correct": false }
        ],
        "explanation": "BinText est un outil GUI pour Windows cité dans le cours pour extraire et localiser du texte dans un fichier binaire."
    },
    {
        "id": "q36",
        "text": "Quelle section du PE Header contient généralement les imports et exports ?",
        "options": [
            { "id": "a", "label": ".text", "correct": false },
            { "id": "b", "label": ".rdata", "correct": true },
            { "id": "c", "label": ".rsrc", "correct": false },
            { "id": "d", "label": ".data", "correct": false }
        ],
        "explanation": "La section .rdata contient souvent les informations d'importation et d'exportation (bien que cela puisse varier selon les compilateurs)."
    },
    {
        "id": "q37",
        "text": "Quel est le risque d'utiliser VirusTotal pour analyser un malware ciblé ?",
        "options": [
            { "id": "a", "label": "Cela peut alerter les attaquants que leur malware a été découvert.", "correct": true },
            { "id": "b", "label": "VirusTotal installe le malware sur votre PC.", "correct": false },
            { "id": "c", "label": "C'est un service payant uniquement.", "correct": false },
            { "id": "d", "label": "VirusTotal ne fonctionne pas avec les fichiers .exe.", "correct": false }
        ],
        "explanation": "En uploadant un fichier sur VirusTotal, l'échantillon est partagé avec la communauté et les éditeurs antivirus, ce qui peut prévenir l'attaquant que son attaque a échoué."
    },
    {
        "id": "q38",
        "text": "Qu'est-ce qu'une Backdoor ?",
        "options": [
            { "id": "a", "label": "Un logiciel qui permet à l'attaquant de contrôler le système à distance.", "correct": true },
            { "id": "b", "label": "Un logiciel qui envoie des spams.", "correct": false },
            { "id": "c", "label": "Un logiciel qui fait peur à l'utilisateur.", "correct": false },
            { "id": "d", "label": "Un logiciel de sauvegarde.", "correct": false }
        ],
        "explanation": "Une backdoor (porte dérobée) offre un accès permanent et discret à l'attaquant sur la machine compromise."
    },
    {
        "id": "q39",
        "text": "Que permet de détecter l'outil PEID ?",
        "options": [
            { "id": "a", "label": "Le type de packer ou de compilateur utilisé pour créer l'exécutable.", "correct": true },
            { "id": "b", "label": "L'adresse IP de l'attaquant.", "correct": false },
            { "id": "c", "label": "Les mots de passe enregistrés.", "correct": false },
            { "id": "d", "label": "La version de Windows.", "correct": false }
        ],
        "explanation": "PEID scanne l'en-tête du fichier pour trouver des signatures connues de packers (comme UPX) ou de cryptors."
    },
    {
        "id": "q40",
        "text": "Quelle commande permet d'obtenir les chaînes de caractères sur Linux ?",
        "options": [
            { "id": "a", "label": "grep", "correct": false },
            { "id": "b", "label": "strings", "correct": true },
            { "id": "c", "label": "cat", "correct": false },
            { "id": "d", "label": "ls", "correct": false }
        ],
        "explanation": "La commande strings est l'outil natif Linux pour extraire les séquences de caractères imprimables d'un fichier binaire."
    },
    {
        "id": "q41",
        "text": "À quoi servent principalement les signatures réseau ?",
        "options": [
            { "id": "a", "label": "À supprimer les fichiers infectés sur le disque dur.", "correct": false },
            { "id": "b", "label": "À créer des règles pour les systèmes de détection d'intrusion (IDS) en analysant le trafic.", "correct": true },
            { "id": "c", "label": "À identifier les clés de registre modifiées.", "correct": false },
            { "id": "d", "label": "À désassembler le code du malware.", "correct": false }
        ],
        "explanation": "Les signatures réseau identifient un logiciel malveillant en analysant le trafic et sont utilisées pour configurer les IDS."
    },
    {
        "id": "q42",
        "text": "Quel outil est spécifiquement mentionné pour l'analyse de la RAM ?",
        "options": [
            { "id": "a", "label": "Wireshark", "correct": false },
            { "id": "b", "label": "Volatility", "correct": true },
            { "id": "c", "label": "Dependency Walker", "correct": false },
            { "id": "d", "label": "PEID", "correct": false }
        ],
        "explanation": "Volatility (et Mandiant Redline) sont des outils pour l'analyse de la RAM."
    },
    {
        "id": "q43",
        "text": "Quelle est la principale caractéristique d'un Downloader ?",
        "options": [
            { "id": "a", "label": "Il chiffre les données.", "correct": false },
            { "id": "b", "label": "Il télécharge et installe le code malveillant principal après avoir obtenu un premier accès.", "correct": true },
            { "id": "c", "label": "Il envoie des spams.", "correct": false },
            { "id": "d", "label": "Il cache les processus actifs.", "correct": false }
        ],
        "explanation": "Le downloader sert à télécharger le véritable contenu malveillant plus tard, une fois l'accès initial établi."
    },
    {
        "id": "q44",
        "text": "Quel type de malware est Stuxnet ?",
        "options": [
            { "id": "a", "label": "Un mass malware.", "correct": false },
            { "id": "b", "label": "Un scareware.", "correct": false },
            { "id": "c", "label": "Un targeted malware", "correct": true },
            { "id": "d", "label": "Un adware.", "correct": false }
        ],
        "explanation": "Stuxnet est donné comme exemple de targeted malware, qui cible une infrastructure spécifique."
    },
    {
        "id": "q45",
        "text": "Qu'est-ce qu'une collision de hash MD5 ?",
        "options": [
            { "id": "a", "label": "Lorsque le hash ne peut pas être calculé.", "correct": false },
            { "id": "b", "label": "Lorsque deux fichiers différents produisent le même hash.", "correct": true },
            { "id": "c", "label": "Lorsque le hash change à chaque exécution.", "correct": false },
            { "id": "d", "label": "Lorsque le hash est trop long.", "correct": false }
        ],
        "explanation": "Une collision survient lorsque deux fichiers distincts génèrent la même empreinte MD5, ce qui est une limite de cette méthode"
    },
    {
        "id": "q46",
        "text": "Quelle est la limitation principale de la commande strings si on ne cherche que de l'ASCII sur un fichier contenant de l'Unicode ?",
        "options": [
            { "id": "a", "label": "Elle plantera.", "correct": false },
            { "id": "b", "label": "Elle s'arrêtera au premier octet nul et manquera le reste de la chaîne.", "correct": true },
            { "id": "c", "label": "Elle affichera tout en double.", "correct": false },
            { "id": "d", "label": "Elle convertira automatiquement en Hexa.", "correct": false }
        ],
        "explanation": "Comme l'Unicode utilise des octets nuls (ex: 42 00 41 00), une recherche ASCII standard s'arrêtera au premier 00."
    },
    {
        "id": "q47",
        "text": "Comment fonctionne le wrapper dans un malware packé ?",
        "options": [
            { "id": "a", "label": "Il télécharge le malware.", "correct": false },
            { "id": "b", "label": "Il s'exécute en premier, décompresse le code malveillant en RAM, puis le lance.", "correct": true },
            { "id": "c", "label": "Il supprime les logs du système.", "correct": false },
            { "id": "d", "label": "Il contacte le serveur C&C.", "correct": false }
        ],
        "explanation": "Le wrapper est le code non chiffré qui s'exécute au démarrage pour décompresser le code réel du malware en mémoire."
    },
    {
        "id": "q48",
        "text": "Quel indice visuel dans les sections PE peut indiquer un packing ?",
        "options": [
            { "id": "a", "label": "La présence de la section .text.", "correct": false },
            { "id": "b", "label": "Des noms de sections inhabituels ou un point d'entrée dans une section de décompression.", "correct": true },
            { "id": "c", "label": "Une section .rsrc très petite.", "correct": false },
            { "id": "d", "label": "L'absence de PE Header.", "correct": false }
        ],
        "explanation": "Des noms de sections bizarres ou un Entry Point pointant ailleurs que vers le code standard sont des signes de packing."
    },
    {
        "id": "q49",
        "text": "Que contient la section .data d'un fichier PE ?",
        "options": [
            { "id": "a", "label": "Le code exécutable.", "correct": false },
            { "id": "b", "label": "Les ressources.", "correct": false },
            { "id": "c", "label": "Les données globales.", "correct": true },
            { "id": "d", "label": "Les informations de relocation.", "correct": false }
        ],
        "explanation": "La section .data est utilisée pour stocker les données globales du programme."
    },
    {
        "id": "q50",
        "text": "Pourquoi le Time Date Stamp du PE Header n'est-il pas toujours fiable ?",
        "options": [
            { "id": "a", "label": "Il est toujours vide.", "correct": false },
            { "id": "b", "label": "Il peut être falsifié par l'attaquant.", "correct": true },
            { "id": "c", "label": "Il dépend du fuseau horaire de l'analyste.", "correct": false },
            { "id": "d", "label": "Windows le met à jour à chaque exécution.", "correct": false }
        ],
        "explanation": "Bien qu'il indique la date de compilation, cette information est facilement falsifiable par le créateur du malware."
    },
    {
        "id": "q51",
        "text": "Quelle est la caractéristique de la liaison statique ?",
        "options": [
            { "id": "a", "label": "Le code de la bibliothèque est copié dans l'exécutable, le rendant plus volumineux.", "correct": true },
            { "id": "b", "label": "Les bibliothèques sont chargées au démarrage de Windows.", "correct": false },
            { "id": "c", "label": "Elle utilise LoadLibrary.", "correct": false },
            { "id": "d", "label": "C'est la méthode la plus courante sous Windows.", "correct": false }
        ],
        "explanation": "La liaison statique intègre tout le code des bibliothèques dans l'exe final, augmentant sa taille. Elle est plus rare sous Windows."
    },
    {
        "id": "q52",
        "text": "Quelles fonctions Windows sont typiques de la liaison à l'exécution ?",
        "options": [
            { "id": "a", "label": "Printf et Scanf.", "correct": false },
            { "id": "b", "label": "LoadLibrary et GetProcAddress.", "correct": true },
            { "id": "c", "label": "Open et Close.", "correct": false },
            { "id": "d", "label": "Connect et Bind.", "correct": false }
        ],
        "explanation": "LoadLibrary et GetProcAddress permettent de charger des DLLs et d'accéder à leurs fonctions dynamiquement pendant l'exécution."
    },
    {
        "id": "q53",
        "text": "Quel est un avantage d'utiliser une VM pour l'analyse ?",
        "options": [
            { "id": "a", "label": "Elle est indétectable.", "correct": false },
            { "id": "b", "label": "Elle protège la machine hôte.", "correct": true },
            { "id": "c", "label": "Elle a un accès direct au GPU.", "correct": false },
            { "id": "d", "label": "Elle accélère l'exécution du malware.", "correct": false }
        ],
        "explanation": "L'utilisation d'une VM permet d'isoler l'infection et de protéger le système d'exploitation de la machine analyste."
    },
    {
        "id": "q54",
        "text": "Quel format de rapport fournissent généralement les outils de Sandbox ?",
        "options": [
            { "id": "a", "label": "MP3", "correct": false },
            { "id": "b", "label": "PDF", "correct": true },
            { "id": "c", "label": "EXE", "correct": false },
            { "id": "d", "label": "DLL", "correct": false }
        ],
        "explanation": "Les sandboxes automatisées produisent généralement un rapport au format PDF facile à lire."
    },
    {
        "id": "q55",
        "text": "Quelle est la syntaxe correcte pour lancer une fonction exportée d'une DLL avec rundll32 ?",
        "options": [
            { "id": "a", "label": "rundll32.exe DLLname -Install", "correct": false },
            { "id": "b", "label": "rundll32.exe DLLname, ExportName", "correct": true },
            { "id": "c", "label": "rundll32.exe -run DLLname", "correct": false },
            { "id": "d", "label": "open DLLname", "correct": false }
        ],
        "explanation": "La commande prend le nom de la DLL suivi d'une virgule et du nom de la fonction (export) à exécuter."
    },
    {
        "id": "q56",
        "text": "Dans Process Monitor, pourquoi l'option de filtrage exclude peut-elle être risquée ?",
        "options": [
            { "id": "a", "label": "Elle consomme trop de mémoire.", "correct": false },
            { "id": "b", "label": "Elle peut masquer une activité malveillante si le malware se fait passer pour un processus exclu.", "correct": true },
            { "id": "c", "label": "Elle supprime les fichiers du disque.", "correct": false },
            { "id": "d", "label": "Elle empêche Windows de démarrer.", "correct": false }
        ],
        "explanation": "Si on exclut des processus normaux, on risque de rater un malware qui utilise l'injection de code dans ces mêmes processus."
    },
    {
        "id": "q57",
        "text": "Quelle est la limite du bouton verify dans l'onglet Image de Process Explorer ?",
        "options": [
            { "id": "a", "label": "Il ne vérifie que la signature sur le disque, pas l'image en mémoire (RAM).", "correct": true },
            { "id": "b", "label": "Il est payant.", "correct": false },
            { "id": "c", "label": "Il ne fonctionne que sur Linux.", "correct": false },
            { "id": "d", "label": "Il efface la signature.", "correct": false }
        ],
        "explanation": "Le bouton verify vérifie la signature du fichier sur le disque, donc il ne détectera pas un 'Process Replacement' en mémoire."
    },
    {
        "id": "q58",
        "text": "Quels mécanismes de sécurité peut-on voir dans l'onglet Image de Process Explorer ?",
        "options": [
            { "id": "a", "label": "Antivirus et Firewall.", "correct": false },
            { "id": "b", "label": "DEP et ASLR.", "correct": true },
            { "id": "c", "label": "SSL et TLS.", "correct": false },
            { "id": "d", "label": "WEP et WPA.", "correct": false }
        ],
        "explanation": "L'onglet Image affiche l'état de la DEP (Data Execution Prevention) et de l'ASLR."
    },
    {
        "id": "q59",
        "text": "Quel outil permet de simuler de nombreux services internet (HTTP, SMTP, FTP...) ?",
        "options": [
            { "id": "a", "label": "INetSim", "correct": true },
            { "id": "b", "label": "Putty", "correct": false },
            { "id": "c", "label": "Resource Hacker", "correct": false },
            { "id": "d", "label": "OllyDbg", "correct": false }
        ],
        "explanation": "INetSim simule un environnement réseau complet avec divers services pour tromper le malware."
    },
    {
        "id": "q60",
        "text": "Quelle commande Ncat permet d'écouter sur un port spécifique ?",
        "options": [
            { "id": "a", "label": "ncat -listen", "correct": false },
            { "id": "b", "label": "ncat -l -p [port]", "correct": true },
            { "id": "c", "label": "ncat -connect [port]", "correct": false },
            { "id": "d", "label": "ncat -scan", "correct": false }
        ],
        "explanation": "La syntaxe pour écouter est 'ncat -l -p [port]'."
    },
    {
        "id": "q61",
        "text": "Qu'est-ce que le Microcode ?",
        "options": [
            { "id": "a", "label": "Un langage de script.", "correct": false },
            { "id": "b", "label": "Le firmware du processeur qui s'exécute sur le hardware.", "correct": true },
            { "id": "c", "label": "Le code source C++.", "correct": false },
            { "id": "d", "label": "Un petit virus.", "correct": false }
        ],
        "explanation": "Le microcode (ou firmware) est la couche juste au-dessus du hardware, spécifique au matériel."
    },
    {
        "id": "q62",
        "text": "En quoi sont transformés les langages interprétés (Java, Python) avant exécution ?",
        "options": [
            { "id": "a", "label": "En code machine directement.", "correct": false },
            { "id": "b", "label": "En Bytecode.", "correct": true },
            { "id": "c", "label": "En HTML.", "correct": false },
            { "id": "d", "label": "En images.", "correct": false }
        ],
        "explanation": "Les langages interprétés sont traduits en bytecode, qui est ensuite exécuté par un interpréteur."
    },
    {
        "id": "q63",
        "text": "Quelle convention de stockage (endianness) est utilisée pour les données envoyées sur le réseau ?",
        "options": [
            { "id": "a", "label": "Big-endian.", "correct": true },
            { "id": "b", "label": "Little-endian.", "correct": false },
            { "id": "c", "label": "Random-endian.", "correct": false },
            { "id": "d", "label": "Mixed-endian.", "correct": false }
        ],
        "explanation": "Le réseau utilise le Big-endian (MSB à gauche), contrairement au x86 qui utilise le Little-endian."
    },
    {
        "id": "q64",
        "text": "Quel flag est vérifié par l'instruction 'JNZ' ?",
        "options": [
            { "id": "a", "label": "Le Flag de Signe .", "correct": false },
            { "id": "b", "label": "Le Flag Zéro.", "correct": true },
            { "id": "c", "label": "Le Flag de Retenue.", "correct": false },
            { "id": "d", "label": "Le Flag d'Overflow.", "correct": false }
        ],
        "explanation": "JNZ saute si le résultat n'est pas zéro, c'est-à-dire si le Zero Flag (ZF) est à 0."
    },
    {
        "id": "q65",
        "text": "Qu'est-ce qu'un NOP Sled ?",
        "options": [
            { "id": "a", "label": "Une technique de glissement de registre.", "correct": false },
            { "id": "b", "label": "Une séquence d'instructions NOP placée avant le shellcode pour faciliter l'exploitation.", "correct": true },
            { "id": "c", "label": "Un type de traîneau numérique.", "correct": false },
            { "id": "d", "label": "Une erreur de compilation.", "correct": false }
        ],
        "explanation": "Le NOP Sled permet d'atteindre le code malveillant même si l'adresse exacte du saut est imprécise."
    },
    {
        "id": "q66",
        "text": "Quelle est la différence entre Step-Over et Step-Into ?",
        "options": [
            { "id": "a", "label": "Step-Into saute les fonctions, Step-Over entre dedans.", "correct": false },
            { "id": "b", "label": "Step-Over exécute la fonction appelée sans s'y arrêter, Step-Into entre dans la fonction.", "correct": true },
            { "id": "c", "label": "Il n'y a aucune différence.", "correct": false },
            { "id": "d", "label": "Step-Into ferme le debugger.", "correct": false }
        ],
        "explanation": "Step-Into détaille l'exécution en entrant dans les appels (CALL), alors que Step-Over les exécute d'un bloc."
    },
    {
        "id": "q67",
        "text": "Quels registres sont utilisés pour les breakpoints matériels ?",
        "options": [
            { "id": "a", "label": "EAX, EBX, ECX.", "correct": false },
            { "id": "b", "label": "DR0 à DR3 et DR7.", "correct": true },
            { "id": "c", "label": "EIP et ESP.", "correct": false },
            { "id": "d", "label": "CS, DS, ES.", "correct": false }
        ],
        "explanation": "Les registres de debug DR0 à DR3 stockent les adresses des breakpoints matériels."
    },
    {
        "id": "q68",
        "text": "Quand survient une exception de première chance ?",
        "options": [
            { "id": "a", "label": "Lorsque le debugger détecte une exception avant que le programme ne la gère.", "correct": true },
            { "id": "b", "label": "Après le crash du programme.", "correct": false },
            { "id": "c", "label": "Au démarrage de Windows.", "correct": false },
            { "id": "d", "label": "Lors de la compilation.", "correct": false }
        ],
        "explanation": "C'est le moment où le debugger intercepte l'exception en premier, avant de laisser le programme tenter de la résoudre."
    },
    {
        "id": "q69",
        "text": "Quel est le risque de sauter manuellement une fonction dans un debugger en changeant l'EIP ?",
        "options": [
            { "id": "a", "label": "Le PC peut redémarrer.", "correct": false },
            { "id": "b", "label": "Le programme peut crasher ou mal fonctionner si la fonction initialisait des variables importantes.", "correct": true },
            { "id": "c", "label": "Le malware sera automatiquement supprimé.", "correct": false },
            { "id": "d", "label": "Rien, c'est une opération sûre.", "correct": false }
        ],
        "explanation": "Sauter une fonction peut laisser le programme dans un état instable (variables non initialisées, stack corrompue)."
    },
    {
        "id": "q70",
        "text": "Quelle instruction est utilisée pour un saut si la condition inférieur est remplie ?",
        "options": [
            { "id": "a", "label": "JL.", "correct": true },
            { "id": "b", "label": "JE.", "correct": false },
            { "id": "c", "label": "JMP.", "correct": false },
            { "id": "d", "label": "JZ.", "correct": false }
        ],
        "explanation": "JL (Jump if Less) est utilisé pour les comparaisons signées."
    },
    {
        "id": "q71",
        "text": "Quelle section PE contient généralement les informations de relocation ?",
        "options": [
            { "id": "a", "label": ".text", "correct": false },
            { "id": "b", "label": ".reloc", "correct": true },
            { "id": "c", "label": ".data", "correct": false },
            { "id": "d", "label": ".rsrc", "correct": false }
        ],
        "explanation": "La section .reloc contient les informations nécessaires pour réajuster les adresses si le programme n'est pas chargé à son adresse préférée."
    },
    {
        "id": "q72",
        "text": "Quel outil populaire de Sysinternals permet d'afficher les processus sous forme d'arbre hiérarchique ?",
        "options": [
            { "id": "a", "label": "Task Manager", "correct": false },
            { "id": "b", "label": "Process Explorer", "correct": true },
            { "id": "c", "label": "Notepad", "correct": false },
            { "id": "d", "label": "Calc", "correct": false }
        ],
        "explanation": "Process Explorer est connu pour sa vue hiérarchique des processus et ses codes couleurs."
    },
    {
        "id": "q73",
        "text": "À quoi sert l'outil CaptureBAT ?",
        "options": [
            { "id": "a", "label": "À capturer des paquets réseaux.", "correct": false },
            { "id": "b", "label": "À surveiller les changements d'état lors de l'exécution.", "correct": true },
            { "id": "c", "label": "À écrire des scripts Batch.", "correct": false },
            { "id": "d", "label": "À cracker des mots de passe.", "correct": false }
        ],
        "explanation": "CaptureBAT est listé comme un outil d'analyse dynamique pour examiner les changements d'état."
    },
    {
        "id": "q74",
        "text": "Quel est le nom de l'opcode 0xCC utilisé pour les breakpoints logiciels ?",
        "options": [
            { "id": "a", "label": "NOP", "correct": false },
            { "id": "b", "label": "INT 3", "correct": true },
            { "id": "c", "label": "MOV", "correct": false },
            { "id": "d", "label": "RET", "correct": false }
        ],
        "explanation": "L'opcode 0xCC correspond à l'interruption 3 (INT 3), utilisée par les debuggers pour stopper l'exécution."
    },
    {
        "id": "q75",
        "text": "Pourquoi utiliser Shift + Impr.écran en mode debug kernel ?",
        "options": [
            { "id": "a", "label": "Pour faire une capture plus rapide.", "correct": false },
            { "id": "b", "label": "Pour éviter un écran bleu de la mort (BSOD).", "correct": true },
            { "id": "c", "label": "Pour enregistrer la vidéo.", "correct": false },
            { "id": "d", "label": "Pour copier le texte.", "correct": false }
        ],
        "explanation": "La touche Impr.écran seule peut causer un crash système en mode debug, d'où l'utilisation de Shift."
    }
]