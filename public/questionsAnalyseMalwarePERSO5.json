[
    {
        "id": "q1",
        "text": "Quel est l'objectif principal d'une signature 'host-based' ?",
        "options": [
            { "id": "a", "label": "Identifier un logiciel malveillant en analysant le trafic réseau.", "correct": false },
            { "id": "b", "label": "Identifier des fichiers ou clés de registre sur le système infecté.", "correct": true },
            { "id": "c", "label": "Empêcher l'exécution du malware en temps réel.", "correct": false },
            { "id": "d", "label": "Créer une empreinte MD5 du fichier.", "correct": false }
        ],
        "explanation": "Les signatures basées sur l'hôte (host-based) servent à identifier les fichiers ou les clés de registre sur le système de la victime qui montrent des signes d'une infection."
    },
    {
        "id": "q2",
        "text": "Quelle technique consiste à étudier le malware sans l'exécuter ?",
        "options": [
            { "id": "a", "label": "Analyse dynamique", "correct": false },
            { "id": "b", "label": "Analyse comportementale", "correct": false },
            { "id": "c", "label": "Analyse statique", "correct": true },
            { "id": "d", "label": "Analyse mémoire", "correct": false }
        ],
        "explanation": "L'analyse statique consiste à étudier le code ou la structure du malware sans le lancer."
    },
    {
        "id": "q3",
        "text": "Quel outil est principalement utilisé pour l'analyse statique avancée (désassemblage) ?",
        "options": [
            { "id": "a", "label": "Wireshark", "correct": false },
            { "id": "b", "label": "ProcMon", "correct": false },
            { "id": "c", "label": "IDA", "correct": true },
            { "id": "d", "label": "RegShot", "correct": false }
        ],
        "explanation": "IDA est un désassembleur puissant utilisé pour voir le code du malware (en assembleur) avant son exécution."
    },
    {
        "id": "q4",
        "text": "Quelle est la différence majeure entre un ver (worm) et un virus ?",
        "options": [
            { "id": "a", "label": "Le ver peut se copier et infecter d'autres machines de manière autonome.", "correct": true },
            { "id": "b", "label": "Le virus ne peut pas être détecté par un antivirus.", "correct": false },
            { "id": "c", "label": "Le ver chiffre les fichiers alors que le virus les efface.", "correct": false },
            { "id": "d", "label": "Il n'y a aucune différence technique.", "correct": false }
        ],
        "explanation": "La distinction principale est que le ver a la capacité de se copier lui-même et d'infecter d'autres machines sans intervention humaine."
    },
    {
        "id": "q5",
        "text": "Que fait un 'rootkit' ?",
        "options": [
            { "id": "a", "label": "Il chiffre les données de l'utilisateur contre une rançon.", "correct": false },
            { "id": "b", "label": "Il cache l'existence d'autres programmes malicieux.", "correct": true },
            { "id": "c", "label": "Il enregistre les frappes au clavier.", "correct": false },
            { "id": "d", "label": "Il lance des attaques DDoS.", "correct": false }
        ],
        "explanation": "Le but d'un rootkit est de dissimuler sa présence ou celle d'autres malwares (comme une backdoor) pour éviter la détection."
    },
    {
        "id": "q6",
        "text": "Quelle est une limite majeure de l'utilisation des hashs (comme MD5) pour identifier un malware ?",
        "options": [
            { "id": "a", "label": "Le hash change si l'attaquant modifie un seul bit du fichier.", "correct": true },
            { "id": "b", "label": "Le calcul du hash est trop lent.", "correct": false },
            { "id": "c", "label": "Les hashs ne fonctionnent que sur les fichiers .exe.", "correct": false },
            { "id": "d", "label": "Le hash révèle le code source du malware.", "correct": false }
        ],
        "explanation": "Bien que le hash soit une empreinte digitale unique, il suffit de changer un seul bit dans le fichier pour que le hash change totalement, rendant la détection par hash inefficace contre le polymorphisme."
    },
    {
        "id": "q7",
        "text": "Lors de l'analyse des chaînes de caractères (strings), quel caractère termine une chaîne ?",
        "options": [
            { "id": "a", "label": "0xFF", "correct": false },
            { "id": "b", "label": "0x00 (Null)", "correct": true },
            { "id": "c", "label": "0x0A (Line Feed)", "correct": false },
            { "id": "d", "label": "0x20 (Space)", "correct": false }
        ],
        "explanation": "Les chaînes de caractères dans le code binaire se terminent par le caractère nul (0x00)."
    },
    {
        "id": "q8",
        "text": "Quelle est la différence entre le format ASCII et Unicode pour les chaînes de caractères ?",
        "options": [
            { "id": "a", "label": "ASCII utilise 2 octets, Unicode 1 octet.", "correct": false },
            { "id": "b", "label": "ASCII utilise 1 octet, Unicode 2 octets (wide characters).", "correct": true },
            { "id": "c", "label": "Unicode ne peut pas être lu par les outils d'analyse.", "correct": false },
            { "id": "d", "label": "ASCII est obsolète et n'est plus utilisé.", "correct": false }
        ],
        "explanation": "En ASCII, chaque caractère occupe 1 octet, alors qu'en Unicode, ils occupent souvent 2 octets, ce qui change la façon dont ils apparaissent en hexadécimal (ex: 42 00 41 00)."
    },
    {
        "id": "q9",
        "text": "Qu'est-ce que le 'packing' d'un malware ?",
        "options": [
            { "id": "a", "label": "L'envoi du malware par email.", "correct": false },
            { "id": "b", "label": "La division du malware en plusieurs fichiers.", "correct": false },
            { "id": "c", "label": "La compression ou le chiffrement du fichier pour dissimuler le code.", "correct": true },
            { "id": "d", "label": "L'installation du malware dans le registre.", "correct": false }
        ],
        "explanation": "Le packing consiste à compresser ou chiffrer l'exécutable pour cacher le code malveillant aux analystes et antivirus. Un 'wrapper' décompresse le code en RAM à l'exécution."
    },
    {
        "id": "q10",
        "text": "Dans l'en-tête PE, comment peut-on repérer un exécutable 'packé' en comparant les tailles ?",
        "options": [
            { "id": "a", "label": "La taille sur le disque (Raw Data) est beaucoup plus grande que la taille en RAM (Virtual Size).", "correct": false },
            { "id": "b", "label": "La taille sur le disque est égale à la taille en RAM.", "correct": false },
            { "id": "c", "label": "La taille sur le disque (Raw Data) est beaucoup plus petite que la taille en RAM (Virtual Size).", "correct": true },
            { "id": "d", "label": "La section .text est vide.", "correct": false }
        ],
        "explanation": "Si l'.exe est packé, le code est compressé sur le disque (petite taille) mais prendra beaucoup de place une fois décompressé en RAM (grande taille)."
    },
    {
        "id": "q11",
        "text": "Quel outil permet de visualiser les dépendances et les fonctions importées (DLL) d'un exécutable ?",
        "options": [
            { "id": "a", "label": "Dependency Walker", "correct": true },
            { "id": "b", "label": "Wireshark", "correct": false },
            { "id": "c", "label": "RegShot", "correct": false },
            { "id": "d", "label": "Resource Hacker", "correct": false }
        ],
        "explanation": "Dependency Walker est utilisé pour lister les DLLs et les fonctions importées/exportées, ce qui donne des indices sur les capacités du programme."
    },
    {
        "id": "q12",
        "text": "Quel type de liaison (linking) est couramment utilisé par les malwares pour charger des bibliothèques uniquement lorsque nécessaire ?",
        "options": [
            { "id": "a", "label": "Liaison statique", "correct": false },
            { "id": "b", "label": "Liaison à l'exécution (Runtime linking)", "correct": true },
            { "id": "c", "label": "Liaison dynamique classique", "correct": false },
            { "id": "d", "label": "Liaison matérielle", "correct": false }
        ],
        "explanation": "La liaison à l'exécution (souvent via LoadLibrary et GetProcAddress) permet au malware de se connecter aux bibliothèques seulement au moment où il en a besoin, souvent pour masquer ses intentions."
    },
    {
        "id": "q13",
        "text": "Quel est l'inconvénient principal de l'analyse dynamique sur une machine réelle ?",
        "options": [
            { "id": "a", "label": "Le malware peut détecter la machine virtuelle.", "correct": false },
            { "id": "b", "label": "Il est difficile de nettoyer l'infection après l'analyse.", "correct": true },
            { "id": "c", "label": "On ne peut pas utiliser d'outils de débogage.", "correct": false },
            { "id": "d", "label": "C'est plus lent qu'une machine virtuelle.", "correct": false }
        ],
        "explanation": "Sur une machine réelle, une fois infectée, il est difficile de garantir que le malware est totalement supprimé, nécessitant souvent la réinstallation de l'OS."
    },
    {
        "id": "q14",
        "text": "Qu'est-ce qu'une 'sandbox' dans le contexte de l'analyse de malware ?",
        "options": [
            { "id": "a", "label": "Un outil pour désassembler le code.", "correct": false },
            { "id": "b", "label": "Un environnement virtuel automatisé qui simule des services réseaux pour observer le comportement.", "correct": true },
            { "id": "c", "label": "Un type de malware qui creuse dans le système.", "correct": false },
            { "id": "d", "label": "Une méthode pour cracker les mots de passe.", "correct": false }
        ],
        "explanation": "Une sandbox (comme Norman Sandbox ou Cuckoo) émule un environnement pour exécuter le malware en sécurité et produire un rapport sur son comportement."
    },
    {
        "id": "q15",
        "text": "Comment exécute-t-on une DLL qui ne peut pas être lancée directement comme un .exe ?",
        "options": [
            { "id": "a", "label": "En la renommant en .exe.", "correct": false },
            { "id": "b", "label": "En utilisant l'outil rundll32.exe.", "correct": true },
            { "id": "c", "label": "En double-cliquant dessus.", "correct": false },
            { "id": "d", "label": "C'est impossible d'exécuter une DLL.", "correct": false }
        ],
        "explanation": "L'outil Windows `rundll32.exe` permet de charger et d'exécuter des fonctions exportées par une DLL."
    },
    {
        "id": "q16",
        "text": "À quoi sert l'outil RegShot ?",
        "options": [
            { "id": "a", "label": "À prendre des captures d'écran du bureau.", "correct": false },
            { "id": "b", "label": "À comparer l'état du registre avant et après l'exécution d'un malware.", "correct": true },
            { "id": "c", "label": "À modifier les clés de registre en temps réel.", "correct": false },
            { "id": "d", "label": "À analyser le trafic réseau.", "correct": false }
        ],
        "explanation": "RegShot prend un instantané du registre avant et après l'infection, puis compare les deux pour montrer les modifications apportées par le malware."
    },
    {
        "id": "q17",
        "text": "Dans Process Explorer, que peut indiquer une différence importante entre les chaînes de caractères (strings) de l'image disque et celles en mémoire ?",
        "options": [
            { "id": "a", "label": "Une erreur de lecture du disque.", "correct": false },
            { "id": "b", "label": "Un remplacement de processus (Process Replacement).", "correct": true },
            { "id": "c", "label": "Que le programme est écrit en Java.", "correct": false },
            { "id": "d", "label": "Rien de particulier, c'est normal.", "correct": false }
        ],
        "explanation": "Si les strings en mémoire sont très différentes de celles sur le disque, cela suggère que l'exécutable en mémoire a été remplacé ou modifié dynamiquement par un malware."
    },
    {
        "id": "q18",
        "text": "Quel est le rôle de l'outil INetSim ?",
        "options": [
            { "id": "a", "label": "Scanner les ports d'une machine distante.", "correct": false },
            { "id": "b", "label": "Simuler des services internet (HTTP, DNS, etc.) pour tromper le malware.", "correct": true },
            { "id": "c", "label": "Télécharger des malwares depuis internet.", "correct": false },
            { "id": "d", "label": "Créer un botnet.", "correct": false }
        ],
        "explanation": "INetSim simule un environnement internet complet (DNS, HTTP, SMTP) pour analyser le comportement réseau du malware sans lui donner un véritable accès au web."
    },
    {
        "id": "q19",
        "text": "Dans l'architecture x86, quelle convention 'endian' est utilisée ?",
        "options": [
            { "id": "a", "label": "Little-endian (LSB à gauche).", "correct": true },
            { "id": "b", "label": "Big-endian (MSB à gauche).", "correct": false },
            { "id": "c", "label": "Middle-endian.", "correct": false },
            { "id": "d", "label": "No-endian.", "correct": false }
        ],
        "explanation": "Les programmes x86 utilisent le format Little-endian, où l'octet de poids faible est stocké à l'adresse la plus basse (ex: 0x42 devient 42 00 00 00)."
    },
    {
        "id": "q20",
        "text": "Comment l'adresse IP 127.0.0.1 (0x7F000001) est-elle stockée dans la RAM (Little-endian) ?",
        "options": [
            { "id": "a", "label": "7F 00 00 01", "correct": false },
            { "id": "b", "label": "01 00 00 7F", "correct": true },
            { "id": "c", "label": "00 00 00 00", "correct": false },
            { "id": "d", "label": "12 70 00 01", "correct": false }
        ],
        "explanation": "En Little-endian, l'ordre des octets est inversé par rapport à l'écriture hexadécimale standard (Big-endian utilisé sur le réseau)."
    },
    {
        "id": "q21",
        "text": "Quelle instruction assembleur correspond à 'JZ' ?",
        "options": [
            { "id": "a", "label": "Jump if Zero (saut si ZF=1).", "correct": true },
            { "id": "b", "label": "Jump if Not Zero (saut si ZF=0).", "correct": false },
            { "id": "c", "label": "Jump if Overflow.", "correct": false },
            { "id": "d", "label": "Jump if Sign.", "correct": false }
        ],
        "explanation": "JZ signifie Jump if Zero, ce qui se produit lorsque le Zero Flag (ZF) est défini à 1 (souvent après une comparaison d'égalité)."
    },
    {
        "id": "q22",
        "text": "Que fait l'instruction NOP (opcode 0x90) ?",
        "options": [
            { "id": "a", "label": "Elle arrête le processeur.", "correct": false },
            { "id": "b", "label": "Elle ne fait rien et passe à l'instruction suivante.", "correct": true },
            { "id": "c", "label": "Elle efface la mémoire.", "correct": false },
            { "id": "d", "label": "Elle provoque une erreur.", "correct": false }
        ],
        "explanation": "NOP (No Operation) ne fait rien. Elle est souvent utilisée pour le 'NOP Sled' dans les exploits de buffer overflow."
    },
    {
        "id": "q23",
        "text": "Quel registre contient l'adresse de la prochaine instruction à exécuter ?",
        "options": [
            { "id": "a", "label": "EAX", "correct": false },
            { "id": "b", "label": "ESP", "correct": false },
            { "id": "c", "label": "EBP", "correct": false },
            { "id": "d", "label": "EIP", "correct": true }
        ],
        "explanation": "EIP (Extended Instruction Pointer) pointe vers l'adresse mémoire de la prochaine instruction que le processeur va exécuter."
    },
    {
        "id": "q24",
        "text": "Quelle est la différence entre un debugger 'user mode' et 'kernel mode' ?",
        "options": [
            { "id": "a", "label": "Le user mode nécessite deux PC.", "correct": false },
            { "id": "b", "label": "Le kernel mode ne peut pas déboguer les drivers.", "correct": false },
            { "id": "c", "label": "Le user mode débogue un seul exécutable isolé, le kernel mode débogue le noyau du système.", "correct": true },
            { "id": "d", "label": "Il n'y a pas de différence.", "correct": false }
        ],
        "explanation": "Le debugger user mode (comme OllyDbg) s'exécute au même niveau que l'application, tandis que le kernel mode (comme WinDbg) permet d'interagir avec le noyau et nécessite souvent une configuration plus complexe."
    },
    {
        "id": "q25",
        "text": "Quelle touche faut-il éviter d'utiliser en mode debug kernel pour ne pas causer un écran bleu ?",
        "options": [
            { "id": "a", "label": "Echap", "correct": false },
            { "id": "b", "label": "Impr.écran (Print Screen)", "correct": true },
            { "id": "c", "label": "F5", "correct": false },
            { "id": "d", "label": "Ctrl+C", "correct": false }
        ],
        "explanation": "La touche Impr.écran provoque un bug connu (écran bleu) en mode debug kernel, il est recommandé d'utiliser Shift+Impr.écran."
    },
    {
        "id": "q26",
        "text": "Dans un debugger, que fait la commande 'Step-Over' ?",
        "options": [
            { "id": "a", "label": "Elle entre dans le détail de chaque fonction appelée.", "correct": false },
            { "id": "b", "label": "Elle exécute l'instruction, mais exécute les appels de fonction en une seule fois sans s'y arrêter.", "correct": true },
            { "id": "c", "label": "Elle redémarre le programme.", "correct": false },
            { "id": "d", "label": "Elle ignore l'instruction actuelle.", "correct": false }
        ],
        "explanation": "Step-Over permet de passer à l'instruction suivante dans le code actuel. Si l'instruction est un CALL, la fonction appelée est exécutée entièrement sans que le debugger ne s'arrête à l'intérieur."
    },
    {
        "id": "q27",
        "text": "Comment fonctionne un breakpoint logiciel (software breakpoint) ?",
        "options": [
            { "id": "a", "label": "Il utilise les registres de debug DR0-DR3.", "correct": false },
            { "id": "b", "label": "Il remplace le premier octet de l'instruction par 0xCC (INT 3).", "correct": true },
            { "id": "c", "label": "Il arrête le ventilateur du CPU.", "correct": false },
            { "id": "d", "label": "Il désactive la carte réseau.", "correct": false }
        ],
        "explanation": "Le debugger remplace l'octet de l'instruction par 0xCC, qui déclenche une interruption (INT 3) pour redonner la main au debugger."
    },
    {
        "id": "q28",
        "text": "Quel est l'avantage principal d'un breakpoint matériel (hardware breakpoint) ?",
        "options": [
            { "id": "a", "label": "Il ne modifie pas le code en mémoire, ce qui le rend plus difficile à détecter.", "correct": true },
            { "id": "b", "label": "Il permet de mettre un nombre illimité de points d'arrêt.", "correct": false },
            { "id": "c", "label": "Il est plus lent que le breakpoint logiciel.", "correct": false },
            { "id": "d", "label": "Il fonctionne même si le PC est éteint.", "correct": false }
        ],
        "explanation": "Contrairement au breakpoint logiciel qui modifie le code (0xCC), le matériel utilise les registres du CPU, évitant ainsi la détection par vérification d'intégrité du code."
    },
    {
        "id": "q29",
        "text": "Que signifie une 'exception de seconde chance' dans un debugger ?",
        "options": [
            { "id": "a", "label": "Le programme a géré l'exception correctement.", "correct": false },
            { "id": "b", "label": "Le debugger a ignoré la première exception.", "correct": false },
            { "id": "c", "label": "L'application n'a pas géré l'exception, elle aurait planté sans le debugger.", "correct": true },
            { "id": "d", "label": "C'est une exception réservée au noyau.", "correct": false }
        ],
        "explanation": "La seconde chance signifie que le programme n'a pas pu résoudre le problème (exception) par lui-même. C'est souvent un signe important lors de l'analyse (crash ou anti-debug)."
    },
    {
        "id": "q30",
        "text": "Pourquoi modifierait-on la valeur du registre EIP (ou RIP) manuellement dans un debugger ?",
        "options": [
            { "id": "a", "label": "Pour changer la couleur du debugger.", "correct": false },
            { "id": "b", "label": "Pour sauter une fonction ou modifier le flux d'exécution du programme.", "correct": true },
            { "id": "c", "label": "Pour augmenter la vitesse du processeur.", "correct": false },
            { "id": "d", "label": "Pour sauvegarder le fichier.", "correct": false }
        ],
        "explanation": "Changer l'EIP permet de rediriger l'exécution, par exemple pour sauter une instruction malveillante ou une vérification de sécurité."
    },
    {
        "id": "q31",
        "text": "Dans l'exemple du malware dépendant de la langue, pourquoi l'analyste modifie-t-il la valeur de retour de 'GetSystemDefaultLCID' ?",
        "options": [
            { "id": "a", "label": "Pour traduire le malware en français.", "correct": false },
            { "id": "b", "label": "Pour simuler une langue spécifique (ex: Chinois) et observer le comportement déclenché.", "correct": true },
            { "id": "c", "label": "Pour faire planter le système.", "correct": false },
            { "id": "d", "label": "Pour corriger une faute d'orthographe dans le malware.", "correct": false }
        ],
        "explanation": "En modifiant la valeur de retour, l'analyste trompe le malware en lui faisant croire qu'il s'exécute sur un système chinois, ce qui peut déclencher (ou empêcher) des actions spécifiques (ex: autodestruction)."
    },
    {
        "id": "q32",
        "text": "Quelle est la règle générale n°1 de l'analyse de malware selon le cours ?",
        "options": [
            { "id": "a", "label": "Il faut absolument comprendre 100% du code.", "correct": false },
            { "id": "b", "label": "Ne pas perdre de temps à tout comprendre, se concentrer sur l'essentiel.", "correct": true },
            { "id": "c", "label": "Toujours utiliser Linux.", "correct": false },
            { "id": "d", "label": "Ne jamais utiliser de machine virtuelle.", "correct": false }
        ],
        "explanation": "Le cours précise qu'il est inutile de passer '1000 ans' à tout comprendre ; il faut se concentrer sur les fonctionnalités importantes."
    },
    {
        "id": "q33",
        "text": "Quel outil permet d'écouter un port TCP (similaire au couteau suisse du réseau) ?",
        "options": [
            { "id": "a", "label": "Ncat (ou Netcat)", "correct": true },
            { "id": "b", "label": "Notepad++", "correct": false },
            { "id": "c", "label": "PEID", "correct": false },
            { "id": "d", "label": "Hashcalc", "correct": false }
        ],
        "explanation": "Ncat permet d'écouter des ports et d'interagir avec les connexions réseau, utile pour voir ce que le malware envoie."
    },
    {
        "id": "q34",
        "text": "Qu'est-ce que l'obfuscation ?",
        "options": [
            { "id": "a", "label": "L'action de rendre le code difficile à lire pour les humains et les outils d'analyse.", "correct": true },
            { "id": "b", "label": "L'action de supprimer le code source.", "correct": false },
            { "id": "c", "label": "L'action de rendre le code plus rapide.", "correct": false },
            { "id": "d", "label": "L'action de commenter le code.", "correct": false }
        ],
        "explanation": "L'obfuscation vise à complexifier l'analyse statique en rendant le code confus ou caché."
    },
    {
        "id": "q35",
        "text": "Quel outil graphique Windows permet de visualiser les chaînes de caractères (Strings) ?",
        "options": [
            { "id": "a", "label": "BinText", "correct": true },
            { "id": "b", "label": "Cmd.exe", "correct": false },
            { "id": "c", "label": "Paint", "correct": false },
            { "id": "d", "label": "Calculatrice", "correct": false }
        ],
        "explanation": "BinText est un outil GUI pour Windows cité dans le cours pour extraire et localiser du texte dans un fichier binaire."
    },
    {
        "id": "q36",
        "text": "Quelle section du PE Header contient généralement les imports et exports ?",
        "options": [
            { "id": "a", "label": ".text", "correct": false },
            { "id": "b", "label": ".rdata", "correct": true },
            { "id": "c", "label": ".rsrc", "correct": false },
            { "id": "d", "label": ".data", "correct": false }
        ],
        "explanation": "La section .rdata contient souvent les informations d'importation et d'exportation (bien que cela puisse varier selon les compilateurs)."
    },
    {
        "id": "q37",
        "text": "Quel est le risque d'utiliser VirusTotal pour analyser un malware ciblé ?",
        "options": [
            { "id": "a", "label": "Cela peut alerter les attaquants que leur malware a été découvert.", "correct": true },
            { "id": "b", "label": "VirusTotal installe le malware sur votre PC.", "correct": false },
            { "id": "c", "label": "C'est un service payant uniquement.", "correct": false },
            { "id": "d", "label": "VirusTotal ne fonctionne pas avec les fichiers .exe.", "correct": false }
        ],
        "explanation": "En uploadant un fichier sur VirusTotal, l'échantillon est partagé avec la communauté et les éditeurs antivirus, ce qui peut prévenir l'attaquant que son attaque a échoué."
    },
    {
        "id": "q38",
        "text": "Qu'est-ce qu'une 'Backdoor' ?",
        "options": [
            { "id": "a", "label": "Un logiciel qui permet à l'attaquant de contrôler le système à distance.", "correct": true },
            { "id": "b", "label": "Un logiciel qui envoie des spams.", "correct": false },
            { "id": "c", "label": "Un logiciel qui fait peur à l'utilisateur.", "correct": false },
            { "id": "d", "label": "Un logiciel de sauvegarde.", "correct": false }
        ],
        "explanation": "Une backdoor (porte dérobée) offre un accès permanent et discret à l'attaquant sur la machine compromise."
    },
    {
        "id": "q39",
        "text": "Que permet de détecter l'outil PEID ?",
        "options": [
            { "id": "a", "label": "Le type de packer ou de compilateur utilisé pour créer l'exécutable.", "correct": true },
            { "id": "b", "label": "L'adresse IP de l'attaquant.", "correct": false },
            { "id": "c", "label": "Les mots de passe enregistrés.", "correct": false },
            { "id": "d", "label": "La version de Windows.", "correct": false }
        ],
        "explanation": "PEID scanne l'en-tête du fichier pour trouver des signatures connues de packers (comme UPX) ou de cryptors."
    },
    {
        "id": "q40",
        "text": "Quelle commande permet d'obtenir les chaînes de caractères sur Linux ?",
        "options": [
            { "id": "a", "label": "grep", "correct": false },
            { "id": "b", "label": "strings", "correct": true },
            { "id": "c", "label": "cat", "correct": false },
            { "id": "d", "label": "ls", "correct": false }
        ],
        "explanation": "La commande 'strings' est l'outil natif Linux pour extraire les séquences de caractères imprimables d'un fichier binaire."
    },
    {
        "id": "q41",
        "text": "À quoi servent principalement les signatures réseau (network signatures) ?",
        "options": [
            { "id": "a", "label": "À supprimer les fichiers infectés sur le disque dur.", "correct": false },
            { "id": "b", "label": "À créer des règles pour les systèmes de détection d'intrusion (IDS) en analysant le trafic.", "correct": true },
            { "id": "c", "label": "À identifier les clés de registre modifiées.", "correct": false },
            { "id": "d", "label": "À désassembler le code du malware.", "correct": false }
        ],
        "explanation": "Les signatures réseau identifient un logiciel malveillant en analysant le trafic et sont utilisées pour configurer les IDS."
    },
    {
        "id": "q42",
        "text": "Quel outil est spécifiquement mentionné pour l'analyse de la RAM (mémoire vive) ?",
        "options": [
            { "id": "a", "label": "Wireshark", "correct": false },
            { "id": "b", "label": "Volatility", "correct": true },
            { "id": "c", "label": "Dependency Walker", "correct": false },
            { "id": "d", "label": "PEID", "correct": false }
        ],
        "explanation": "Volatility (et Mandiant Redline) sont cités comme outils pour l'analyse de la RAM."
    },
    {
        "id": "q43",
        "text": "Quelle est la principale caractéristique d'un 'Downloader' ?",
        "options": [
            { "id": "a", "label": "Il chiffre les données.", "correct": false },
            { "id": "b", "label": "Il télécharge et installe le code malveillant principal après avoir obtenu un premier accès.", "correct": true },
            { "id": "c", "label": "Il envoie des spams.", "correct": false },
            { "id": "d", "label": "Il cache les processus actifs.", "correct": false }
        ],
        "explanation": "Le downloader sert à télécharger le véritable contenu malveillant plus tard, une fois l'accès initial établi."
    },
    {
        "id": "q44",
        "text": "Quel type de malware est 'Stuxnet' ?",
        "options": [
            { "id": "a", "label": "Un mass malware.", "correct": false },
            { "id": "b", "label": "Un scareware.", "correct": false },
            { "id": "c", "label": "Un targeted malware (ciblé).", "correct": true },
            { "id": "d", "label": "Un adware.", "correct": false }
        ],
        "explanation": "Stuxnet est donné comme exemple de 'targeted malware', qui cible une infrastructure spécifique."
    },
    {
        "id": "q45",
        "text": "Qu'est-ce qu'une collision de hash MD5 ?",
        "options": [
            { "id": "a", "label": "Lorsque le hash ne peut pas être calculé.", "correct": false },
            { "id": "b", "label": "Lorsque deux fichiers différents produisent le même hash.", "correct": true },
            { "id": "c", "label": "Lorsque le hash change à chaque exécution.", "correct": false },
            { "id": "d", "label": "Lorsque le hash est trop long.", "correct": false }
        ],
        "explanation": "Une collision survient lorsque deux fichiers distincts génèrent la même empreinte MD5, ce qui est une limite de cette méthode"
    },
    {
        "id": "q46",
        "text": "Quelle est la limitation principale de la commande 'strings' si on ne cherche que de l'ASCII sur un fichier contenant de l'Unicode ?",
        "options": [
            { "id": "a", "label": "Elle plantera.", "correct": false },
            { "id": "b", "label": "Elle s'arrêtera au premier octet nul (0x00) et manquera le reste de la chaîne.", "correct": true },
            { "id": "c", "label": "Elle affichera tout en double.", "correct": false },
            { "id": "d", "label": "Elle convertira automatiquement en Hexa.", "correct": false }
        ],
        "explanation": "Comme l'Unicode utilise des octets nuls (ex: 42 00 41 00), une recherche ASCII standard s'arrêtera au premier 00."
    },
    {
        "id": "q47",
        "text": "Comment fonctionne le 'Wrapper' ou 'Stub' dans un malware packé ?",
        "options": [
            { "id": "a", "label": "Il télécharge le malware.", "correct": false },
            { "id": "b", "label": "Il s'exécute en premier, décompresse le code malveillant en RAM, puis le lance.", "correct": true },
            { "id": "c", "label": "Il supprime les logs du système.", "correct": false },
            { "id": "d", "label": "Il contacte le serveur C&C.", "correct": false }
        ],
        "explanation": "Le wrapper est le code non chiffré qui s'exécute au démarrage pour décompresser le code réel du malware en mémoire."
    },
    {
        "id": "q48",
        "text": "Quel indice visuel dans les sections PE peut indiquer un packing ?",
        "options": [
            { "id": "a", "label": "La présence de la section .text.", "correct": false },
            { "id": "b", "label": "Des noms de sections inhabituels ou un point d'entrée dans une section de décompression.", "correct": true },
            { "id": "c", "label": "Une section .rsrc très petite.", "correct": false },
            { "id": "d", "label": "L'absence de PE Header.", "correct": false }
        ],
        "explanation": "Des noms de sections bizarres ou un Entry Point pointant ailleurs que vers le code standard sont des signes de packing."
    },
    {
        "id": "q49",
        "text": "Que contient la section .data d'un fichier PE ?",
        "options": [
            { "id": "a", "label": "Le code exécutable.", "correct": false },
            { "id": "b", "label": "Les ressources (images, icônes).", "correct": false },
            { "id": "c", "label": "Les données globales.", "correct": true },
            { "id": "d", "label": "Les informations de relocation.", "correct": false }
        ],
        "explanation": "La section .data est utilisée pour stocker les données globales du programme."
    },
    {
        "id": "q50",
        "text": "Pourquoi le 'Time Date Stamp' du PE Header n'est-il pas toujours fiable ?",
        "options": [
            { "id": "a", "label": "Il est toujours vide.", "correct": false },
            { "id": "b", "label": "Il peut être falsifié par l'attaquant.", "correct": true },
            { "id": "c", "label": "Il dépend du fuseau horaire de l'analyste.", "correct": false },
            { "id": "d", "label": "Windows le met à jour à chaque exécution.", "correct": false }
        ],
        "explanation": "Bien qu'il indique la date de compilation, cette information est facilement falsifiable par le créateur du malware."
    },
    {
        "id": "q51",
        "text": "Quelle est la caractéristique de la 'liaison statique' (static linking) ?",
        "options": [
            { "id": "a", "label": "Le code de la bibliothèque est copié dans l'exécutable, le rendant plus volumineux.", "correct": true },
            { "id": "b", "label": "Les bibliothèques sont chargées au démarrage de Windows.", "correct": false },
            { "id": "c", "label": "Elle utilise LoadLibrary.", "correct": false },
            { "id": "d", "label": "C'est la méthode la plus courante sous Windows.", "correct": false }
        ],
        "explanation": "La liaison statique intègre tout le code des bibliothèques dans l'exe final, augmentant sa taille. Elle est plus rare sous Windows."
    },
    {
        "id": "q52",
        "text": "Quelles fonctions Windows sont typiques de la 'liaison à l'exécution' (runtime linking) ?",
        "options": [
            { "id": "a", "label": "Printf et Scanf.", "correct": false },
            { "id": "b", "label": "LoadLibrary et GetProcAddress.", "correct": true },
            { "id": "c", "label": "Open et Close.", "correct": false },
            { "id": "d", "label": "Connect et Bind.", "correct": false }
        ],
        "explanation": "LoadLibrary et GetProcAddress permettent de charger des DLLs et d'accéder à leurs fonctions dynamiquement pendant l'exécution."
    },
    {
        "id": "q53",
        "text": "Quel est un avantage d'utiliser une VM pour l'analyse ?",
        "options": [
            { "id": "a", "label": "Elle est indétectable.", "correct": false },
            { "id": "b", "label": "Elle protège la machine hôte.", "correct": true },
            { "id": "c", "label": "Elle a un accès direct au GPU.", "correct": false },
            { "id": "d", "label": "Elle accélère l'exécution du malware.", "correct": false }
        ],
        "explanation": "L'utilisation d'une VM permet d'isoler l'infection et de protéger le système d'exploitation de la machine analyste."
    },
    {
        "id": "q54",
        "text": "Quel format de rapport fournissent généralement les outils de Sandbox ?",
        "options": [
            { "id": "a", "label": "MP3", "correct": false },
            { "id": "b", "label": "PDF", "correct": true },
            { "id": "c", "label": "EXE", "correct": false },
            { "id": "d", "label": "DLL", "correct": false }
        ],
        "explanation": "Les sandboxes automatisées produisent généralement un rapport au format PDF facile à lire."
    },
    {
        "id": "q55",
        "text": "Quelle est la syntaxe correcte pour lancer une fonction exportée d'une DLL avec rundll32 ?",
        "options": [
            { "id": "a", "label": "rundll32.exe DLLname -Install", "correct": false },
            { "id": "b", "label": "rundll32.exe DLLname, ExportName", "correct": true },
            { "id": "c", "label": "rundll32.exe -run DLLname", "correct": false },
            { "id": "d", "label": "open DLLname", "correct": false }
        ],
        "explanation": "La commande prend le nom de la DLL suivi d'une virgule et du nom de la fonction (export) à exécuter."
    },
    {
        "id": "q56",
        "text": "Dans Process Monitor, pourquoi l'option de filtrage 'Exclude' peut-elle être risquée ?",
        "options": [
            { "id": "a", "label": "Elle consomme trop de mémoire.", "correct": false },
            { "id": "b", "label": "Elle peut masquer une activité malveillante si le malware se fait passer pour un processus exclu.", "correct": true },
            { "id": "c", "label": "Elle supprime les fichiers du disque.", "correct": false },
            { "id": "d", "label": "Elle empêche Windows de démarrer.", "correct": false }
        ],
        "explanation": "Si on exclut des processus 'normaux', on risque de rater un malware qui utilise l'injection de code dans ces mêmes processus."
    },
    {
        "id": "q57",
        "text": "Quelle est la limite du bouton 'Verify' dans l'onglet Image de Process Explorer ?",
        "options": [
            { "id": "a", "label": "Il ne vérifie que la signature sur le disque, pas l'image en mémoire (RAM).", "correct": true },
            { "id": "b", "label": "Il est payant.", "correct": false },
            { "id": "c", "label": "Il ne fonctionne que sur Linux.", "correct": false },
            { "id": "d", "label": "Il efface la signature.", "correct": false }
        ],
        "explanation": "Le bouton Verify vérifie la signature du fichier sur le disque, donc il ne détectera pas un 'Process Replacement' en mémoire."
    },
    {
        "id": "q58",
        "text": "Quels mécanismes de sécurité peut-on voir dans l'onglet Image de Process Explorer ?",
        "options": [
            { "id": "a", "label": "Antivirus et Firewall.", "correct": false },
            { "id": "b", "label": "DEP et ASLR.", "correct": true },
            { "id": "c", "label": "SSL et TLS.", "correct": false },
            { "id": "d", "label": "WEP et WPA.", "correct": false }
        ],
        "explanation": "L'onglet Image affiche l'état de la DEP (Data Execution Prevention) et de l'ASLR."
    },
    {
        "id": "q59",
        "text": "Quel outil permet de simuler de nombreux services internet (HTTP, SMTP, FTP...) ?",
        "options": [
            { "id": "a", "label": "INetSim", "correct": true },
            { "id": "b", "label": "Putty", "correct": false },
            { "id": "c", "label": "Resource Hacker", "correct": false },
            { "id": "d", "label": "OllyDbg", "correct": false }
        ],
        "explanation": "INetSim simule un environnement réseau complet avec divers services pour tromper le malware."
    },
    {
        "id": "q60",
        "text": "Quelle commande Ncat permet d'écouter sur un port spécifique ?",
        "options": [
            { "id": "a", "label": "ncat -listen", "correct": false },
            { "id": "b", "label": "ncat -l -p [port]", "correct": true },
            { "id": "c", "label": "ncat -connect [port]", "correct": false },
            { "id": "d", "label": "ncat -scan", "correct": false }
        ],
        "explanation": "La syntaxe pour écouter est 'ncat -l -p [port]'."
    },
    {
        "id": "q61",
        "text": "Qu'est-ce que le 'Microcode' ?",
        "options": [
            { "id": "a", "label": "Un langage de script.", "correct": false },
            { "id": "b", "label": "Le firmware du processeur qui s'exécute sur le hardware.", "correct": true },
            { "id": "c", "label": "Le code source C++.", "correct": false },
            { "id": "d", "label": "Un petit virus.", "correct": false }
        ],
        "explanation": "Le microcode (ou firmware) est la couche juste au-dessus du hardware, spécifique au matériel."
    },
    {
        "id": "q62",
        "text": "En quoi sont transformés les langages interprétés (Java, Python) avant exécution ?",
        "options": [
            { "id": "a", "label": "En code machine directement.", "correct": false },
            { "id": "b", "label": "En Bytecode (représentation intermédiaire).", "correct": true },
            { "id": "c", "label": "En HTML.", "correct": false },
            { "id": "d", "label": "En images.", "correct": false }
        ],
        "explanation": "Les langages interprétés sont traduits en bytecode, qui est ensuite exécuté par un interpréteur."
    },
    {
        "id": "q63",
        "text": "Quelle convention de stockage (endianness) est utilisée pour les données envoyées sur le réseau ?",
        "options": [
            { "id": "a", "label": "Big-endian.", "correct": true },
            { "id": "b", "label": "Little-endian.", "correct": false },
            { "id": "c", "label": "Random-endian.", "correct": false },
            { "id": "d", "label": "Mixed-endian.", "correct": false }
        ],
        "explanation": "Le réseau utilise le Big-endian (MSB à gauche), contrairement au x86 qui utilise le Little-endian."
    },
    {
        "id": "q64",
        "text": "Quel flag est vérifié par l'instruction 'JNZ' (Jump if Not Zero) ?",
        "options": [
            { "id": "a", "label": "Le Flag de Signe (SF).", "correct": false },
            { "id": "b", "label": "Le Flag Zéro (ZF = 0).", "correct": true },
            { "id": "c", "label": "Le Flag de Retenue (CF).", "correct": false },
            { "id": "d", "label": "Le Flag d'Overflow (OF).", "correct": false }
        ],
        "explanation": "JNZ saute si le résultat n'est pas zéro, c'est-à-dire si le Zero Flag (ZF) est à 0."
    },
    {
        "id": "q65",
        "text": "Qu'est-ce qu'un 'NOP Sled' ?",
        "options": [
            { "id": "a", "label": "Une technique de glissement de registre.", "correct": false },
            { "id": "b", "label": "Une séquence d'instructions NOP (0x90) placée avant le shellcode pour faciliter l'exploitation.", "correct": true },
            { "id": "c", "label": "Un type de traîneau numérique.", "correct": false },
            { "id": "d", "label": "Une erreur de compilation.", "correct": false }
        ],
        "explanation": "Le NOP Sled permet d'atteindre le code malveillant même si l'adresse exacte du saut est imprécise."
    },
    {
        "id": "q66",
        "text": "Quelle est la différence entre 'Step-Over' et 'Step-Into' ?",
        "options": [
            { "id": "a", "label": "Step-Into saute les fonctions, Step-Over entre dedans.", "correct": false },
            { "id": "b", "label": "Step-Over exécute la fonction appelée sans s'y arrêter, Step-Into entre dans la fonction.", "correct": true },
            { "id": "c", "label": "Il n'y a aucune différence.", "correct": false },
            { "id": "d", "label": "Step-Into ferme le debugger.", "correct": false }
        ],
        "explanation": "Step-Into détaille l'exécution en entrant dans les appels (CALL), alors que Step-Over les exécute d'un bloc."
    },
    {
        "id": "q67",
        "text": "Quels registres sont utilisés pour les breakpoints matériels (hardware breakpoints) ?",
        "options": [
            { "id": "a", "label": "EAX, EBX, ECX.", "correct": false },
            { "id": "b", "label": "DR0 à DR3 (et DR7 pour le contrôle).", "correct": true },
            { "id": "c", "label": "EIP et ESP.", "correct": false },
            { "id": "d", "label": "CS, DS, ES.", "correct": false }
        ],
        "explanation": "Les registres de debug DR0 à DR3 stockent les adresses des breakpoints matériels."
    },
    {
        "id": "q68",
        "text": "Quand survient une 'exception de première chance' ?",
        "options": [
            { "id": "a", "label": "Lorsque le debugger détecte une exception avant que le programme ne la gère.", "correct": true },
            { "id": "b", "label": "Après le crash du programme.", "correct": false },
            { "id": "c", "label": "Au démarrage de Windows.", "correct": false },
            { "id": "d", "label": "Lors de la compilation.", "correct": false }
        ],
        "explanation": "C'est le moment où le debugger intercepte l'exception en premier, avant de laisser le programme tenter de la résoudre."
    },
    {
        "id": "q69",
        "text": "Quel est le risque de sauter manuellement une fonction dans un debugger (en changeant l'EIP) ?",
        "options": [
            { "id": "a", "label": "Le PC peut redémarrer.", "correct": false },
            { "id": "b", "label": "Le programme peut crasher ou mal fonctionner si la fonction initialisait des variables importantes.", "correct": true },
            { "id": "c", "label": "Le malware sera automatiquement supprimé.", "correct": false },
            { "id": "d", "label": "Rien, c'est une opération sûre.", "correct": false }
        ],
        "explanation": "Sauter une fonction peut laisser le programme dans un état instable (variables non initialisées, stack corrompue)."
    },
    {
        "id": "q70",
        "text": "Quelle instruction est utilisée pour un saut si la condition 'inférieur' (Less) est remplie (signé) ?",
        "options": [
            { "id": "a", "label": "JL (Jump if Less).", "correct": true },
            { "id": "b", "label": "JE (Jump if Equal).", "correct": false },
            { "id": "c", "label": "JMP (Jump).", "correct": false },
            { "id": "d", "label": "JZ (Jump Zero).", "correct": false }
        ],
        "explanation": "JL (Jump if Less) est utilisé pour les comparaisons signées."
    },
    {
        "id": "q71",
        "text": "Quelle section PE contient généralement les informations de relocation ?",
        "options": [
            { "id": "a", "label": ".text", "correct": false },
            { "id": "b", "label": ".reloc", "correct": true },
            { "id": "c", "label": ".data", "correct": false },
            { "id": "d", "label": ".rsrc", "correct": false }
        ],
        "explanation": "La section .reloc contient les informations nécessaires pour réajuster les adresses si le programme n'est pas chargé à son adresse préférée."
    },
    {
        "id": "q72",
        "text": "Quel outil populaire de Sysinternals permet d'afficher les processus sous forme d'arbre hiérarchique ?",
        "options": [
            { "id": "a", "label": "Task Manager", "correct": false },
            { "id": "b", "label": "Process Explorer", "correct": true },
            { "id": "c", "label": "Notepad", "correct": false },
            { "id": "d", "label": "Calc", "correct": false }
        ],
        "explanation": "Process Explorer est connu pour sa vue hiérarchique des processus et ses codes couleurs."
    },
    {
        "id": "q73",
        "text": "À quoi sert l'outil 'CaptureBAT' ?",
        "options": [
            { "id": "a", "label": "À capturer des paquets réseaux.", "correct": false },
            { "id": "b", "label": "À surveiller les changements d'état lors de l'exécution (analyse dynamique).", "correct": true },
            { "id": "c", "label": "À écrire des scripts Batch.", "correct": false },
            { "id": "d", "label": "À cracker des mots de passe.", "correct": false }
        ],
        "explanation": "CaptureBAT est listé comme un outil d'analyse dynamique pour examiner les changements d'état."
    },
    {
        "id": "q74",
        "text": "Quel est le nom de l'opcode 0xCC utilisé pour les breakpoints logiciels ?",
        "options": [
            { "id": "a", "label": "NOP", "correct": false },
            { "id": "b", "label": "INT 3", "correct": true },
            { "id": "c", "label": "MOV", "correct": false },
            { "id": "d", "label": "RET", "correct": false }
        ],
        "explanation": "L'opcode 0xCC correspond à l'interruption 3 (INT 3), utilisée par les debuggers pour stopper l'exécution."
    },
    {
        "id": "q75",
        "text": "Pourquoi utiliser 'Shift + Impr.écran' en mode debug kernel ?",
        "options": [
            { "id": "a", "label": "Pour faire une capture plus rapide.", "correct": false },
            { "id": "b", "label": "Pour éviter un écran bleu de la mort (BSOD).", "correct": true },
            { "id": "c", "label": "Pour enregistrer la vidéo.", "correct": false },
            { "id": "d", "label": "Pour copier le texte.", "correct": false }
        ],
        "explanation": "La touche Impr.écran seule peut causer un crash système en mode debug, d'où l'utilisation de Shift."
    },
    {
        "id": "q76",
        "text": "Quel type de malware est conçu pour effrayer l'utilisateur (ex: faux antivirus) ?",
        "options": [
            { "id": "a", "label": "Ransomware", "correct": false },
            { "id": "b", "label": "Scareware", "correct": true },
            { "id": "c", "label": "Spyware", "correct": false },
            { "id": "d", "label": "Worm", "correct": false }
        ],
        "explanation": "Le scareware utilise la peur (fausses alertes) pour inciter l'utilisateur à payer ou télécharger quelque chose."
    },
    {
        "id": "q77",
        "text": "Quel outil permet de modifier les ressources (icônes, chaînes) d'un exécutable ?",
        "options": [
            { "id": "a", "label": "Resource Hacker", "correct": true },
            { "id": "b", "label": "Wireshark", "correct": false },
            { "id": "c", "label": "Nmap", "correct": false },
            { "id": "d", "label": "Strings", "correct": false }
        ],
        "explanation": "Resource Hacker exploite la section .rsrc pour voir et modifier les ressources."
    },
    {
        "id": "q78",
        "text": "Qu'est-ce qu'un 'Launcher' ?",
        "options": [
            { "id": "a", "label": "Un programme qui lance le malware déjà présent sur la machine.", "correct": true },
            { "id": "b", "label": "Un programme qui télécharge le malware.", "correct": false },
            { "id": "c", "label": "Un programme qui supprime le malware.", "correct": false },
            { "id": "d", "label": "Un programme qui crypte les fichiers.", "correct": false }
        ],
        "explanation": "Le launcher est un exécutable dont le but est de démarrer un code malveillant qui se trouve déjà sur le système."
    },
    {
        "id": "q79",
        "text": "Quelle instruction assembleur déplace une valeur dans un registre ?",
        "options": [
            { "id": "a", "label": "ADD", "correct": false },
            { "id": "b", "label": "MOV", "correct": true },
            { "id": "c", "label": "SUB", "correct": false },
            { "id": "d", "label": "JMP", "correct": false }
        ],
        "explanation": "MOV (Move) est l'instruction de base pour transférer des données (ex: mov ecx, 0x42)."
    },
    {
        "id": "q80",
        "text": "Quelle est la particularité d'un 'Mass Malware' ?",
        "options": [
            { "id": "a", "label": "Il cible une entreprise précise.", "correct": false },
            { "id": "b", "label": "Il infecte le plus de machines possibles sans cible particulière.", "correct": true },
            { "id": "c", "label": "Il est impossible à détecter.", "correct": false },
            { "id": "d", "label": "Il ne fonctionne que sur Mac.", "correct": false }
        ],
        "explanation": "Le mass malware vise la quantité plutôt que la qualité, essayant d'infecter tout le monde indifféremment."
    },
    {
        "id": "q81",
        "text": "Quel est l'un des objectifs majeurs de la génération de signatures lors de l'analyse ?",
        "options": [
            { "id": "a", "label": "Créer des règles pour les pare-feux uniquement.", "correct": false },
            { "id": "b", "label": "Nourrir les systèmes de détection d'intrusion (IDS) pour identifier le malware sur le réseau.", "correct": true },
            { "id": "c", "label": "Hacker le serveur de l'attaquant.", "correct": false },
            { "id": "d", "label": "Réécrire le code du malware.", "correct": false }
        ],
        "explanation": "Le cours mentionne que l'analyse sert à trouver des signatures pour les systèmes de détection d'intrusion afin de mesurer et contenir les dommages."
    },
    {
        "id": "q82",
        "text": "Quelle est la particularité des signatures 'host-based' par rapport aux signatures antivirus classiques ?",
        "options": [
            { "id": "a", "label": "Elles se basent sur ce que le malware a fait sur le système (clés de registre, fichiers créés) plutôt que sur le fichier lui-même.", "correct": true },
            { "id": "b", "label": "Elles sont moins efficaces.", "correct": false },
            { "id": "c", "label": "Elles analysent uniquement la RAM.", "correct": false },
            { "id": "d", "label": "Elles nécessitent une connexion internet.", "correct": false }
        ],
        "explanation": "Les signatures basées sur l'hôte se concentrent sur les traces d'infection laissées sur la machine victime."
    },
    {
        "id": "q83",
        "text": "Quel outil est classé dans l'analyse statique 'basique' (basic static analysis) ?",
        "options": [
            { "id": "a", "label": "IDA Pro", "correct": false },
            { "id": "b", "label": "VirusTotal", "correct": true },
            { "id": "c", "label": "OllyDbg", "correct": false },
            { "id": "d", "label": "Wireshark", "correct": false }
        ],
        "explanation": "L'analyse statique basique inclut des outils rapides comme VirusTotal et la commande strings, avant de passer au désassemblage."
    },
    {
        "id": "q84",
        "text": "Qu'est-ce qu'un 'Botnet' ?",
        "options": [
            { "id": "a", "label": "Un réseau de machines infectées contrôlées par un serveur maître.", "correct": true },
            { "id": "b", "label": "Un robot qui nettoie le net.", "correct": false },
            { "id": "c", "label": "Un logiciel qui crypte les données.", "correct": false },
            { "id": "d", "label": "Une attaque sur le BIOS.", "correct": false }
        ],
        "explanation": "Le botnet implique qu'un serveur ou une machine contrôle le malware présent sur de multiples machines infectées."
    },
    {
        "id": "q85",
        "text": "Quel type de malware est un 'Keylogger' ?",
        "options": [
            { "id": "a", "label": "Ransomware", "correct": false },
            { "id": "b", "label": "Information Stealing Malware", "correct": true },
            { "id": "c", "label": "Launcher", "correct": false },
            { "id": "d", "label": "Rootkit", "correct": false }
        ],
        "explanation": "Les keyloggers sont cités comme exemple de malwares voleurs d'informations (Information Stealing Malware)."
    },
    {
        "id": "q86",
        "text": "Quel est le but d'un 'Spam-sending malware' ?",
        "options": [
            { "id": "a", "label": "Utiliser la machine infectée pour envoyer des courriers indésirables.", "correct": true },
            { "id": "b", "label": "Afficher des publicités sur le bureau.", "correct": false },
            { "id": "c", "label": "Voler des comptes bancaires.", "correct": false },
            { "id": "d", "label": "Détruire le disque dur.", "correct": false }
        ],
        "explanation": "L'attaquant utilise la puissance et la connexion de la machine victime pour diffuser du spam."
    },
    {
        "id": "q87",
        "text": "Quelle est la règle générale n°2 de l'analyse de malware ?",
        "options": [
            { "id": "a", "label": "Utiliser des outils variés, si l'un échoue, un autre réussira peut-être.", "correct": true },
            { "id": "b", "label": "Toujours payer la rançon.", "correct": false },
            { "id": "c", "label": "Ne jamais utiliser de debugger.", "correct": false },
            { "id": "d", "label": "Formater le PC immédiatement.", "correct": false }
        ],
        "explanation": "Il ne faut pas se fier à un seul outil ; la variété des approches permet de contourner les protections ou les échecs d'analyse."
    },
    {
        "id": "q88",
        "text": "Outre l'identification, quel est un objectif secondaire du hachage (hash) ?",
        "options": [
            { "id": "a", "label": "Partager des références de malwares entre analystes sans échanger les fichiers dangereux.", "correct": true },
            { "id": "b", "label": "Compresser le fichier.", "correct": false },
            { "id": "c", "label": "Exécuter le malware en sécurité.", "correct": false },
            { "id": "d", "label": "Traduire le code machine.", "correct": false }
        ],
        "explanation": "Le hash permet de parler d'un malware et de vérifier si quelqu'un l'a déjà analysé sans avoir à transférer le fichier exécutable lui-même."
    },
    {
        "id": "q89",
        "text": "Quel type d'informations cherche-t-on généralement avec la commande 'strings' ?",
        "options": [
            { "id": "a", "label": "Des adresses IP, URLs, noms de fichiers et messages d'erreur.", "correct": true },
            { "id": "b", "label": "La couleur des pixels.", "correct": false },
            { "id": "c", "label": "La vitesse du processeur.", "correct": false },
            { "id": "d", "label": "Le nom du fabricant du clavier.", "correct": false }
        ],
        "explanation": "Ces chaînes de caractères donnent souvent des indices sur les serveurs de commande (C&C) ou les fichiers ciblés."
    },
    {
        "id": "q90",
        "text": "Quel est l'avantage de l'outil 'BinText' par rapport à la commande 'strings' classique ?",
        "options": [
            { "id": "a", "label": "Il montre la position du texte dans le fichier ET en mémoire.", "correct": true },
            { "id": "b", "label": "Il est plus rapide.", "correct": false },
            { "id": "c", "label": "Il fonctionne sur Linux.", "correct": false },
            { "id": "d", "label": "Il déchiffre automatiquement le malware.", "correct": false }
        ],
        "explanation": "BinText offre une interface graphique qui aide à localiser physiquement les chaînes, ce qui est utile pour comprendre la structure."
    },
    {
        "id": "q91",
        "text": "Comment se comportent 'Virtual Size' et 'Size of Raw Data' dans un exécutable NON packé ?",
        "options": [
            { "id": "a", "label": "Elles sont presque égales.", "correct": true },
            { "id": "b", "label": "Virtual Size est nulle.", "correct": false },
            { "id": "c", "label": "Raw Data est nul.", "correct": false },
            { "id": "d", "label": "Elles sont totalement différentes.", "correct": false }
        ],
        "explanation": "Si le programme n'est pas compressé, la taille qu'il occupe sur le disque est sensiblement la même que celle qu'il occupera en mémoire."
    },
    {
        "id": "q92",
        "text": "Qu'est-ce que la 'liaison dynamique' (dynamic linking) ?",
        "options": [
            { "id": "a", "label": "L'OS charge les bibliothèques au moment où le programme est chargé.", "correct": true },
            { "id": "b", "label": "Le programme contient tout le code des bibliothèques.", "correct": false },
            { "id": "c", "label": "Le programme charge les bibliothèques manuellement avec LoadLibrary.", "correct": false },
            { "id": "d", "label": "C'est une méthode réservée à Linux.", "correct": false }
        ],
        "explanation": "C'est la méthode standard où l'OS connecte le programme aux DLLs nécessaires lors de son lancement."
    },
    {
        "id": "q93",
        "text": "Quel outil permet de faire du 'kernel debugging' moderne sur un seul PC ?",
        "options": [
            { "id": "a", "label": "Mark Russinovich's LiveKD", "correct": true },
            { "id": "b", "label": "Notepad", "correct": false },
            { "id": "c", "label": "Calculator", "correct": false },
            { "id": "d", "label": "Paint", "correct": false }
        ],
        "explanation": "LiveKD permet d'inspecter le noyau du système en cours d'exécution sans avoir besoin d'un second PC via un câble série."
    },
    {
        "id": "q94",
        "text": "Pourquoi attacherait-on un debugger à un processus DÉJÀ en cours d'exécution ?",
        "options": [
            { "id": "a", "label": "Parce que le malware peut refuser de se lancer s'il détecte qu'il est démarré par un debugger.", "correct": true },
            { "id": "b", "label": "C'est la seule façon de debugger.", "correct": false },
            { "id": "c", "label": "Pour économiser de la RAM.", "correct": false },
            { "id": "d", "label": "Pour aller plus vite.", "correct": false }
        ],
        "explanation": "Cette méthode contourne certaines techniques anti-debug qui vérifient l'environnement au démarrage (Start with debugger vs Attach)."
    },
    {
        "id": "q95",
        "text": "Dans quel contexte utilise-t-on préférentiellement le 'Step-Over' ?",
        "options": [
            { "id": "a", "label": "Pour les appels aux API Windows connues (ex: CreateFile, recv).", "correct": true },
            { "id": "b", "label": "Pour les fonctions internes du malware.", "correct": false },
            { "id": "c", "label": "Pour ignorer tout le code.", "correct": false },
            { "id": "d", "label": "Pour revenir en arrière.", "correct": false }
        ],
        "explanation": "Il est inutile de debugger ligne par ligne le code de Microsoft (API Windows), on sait ce qu'il fait, donc on passe par-dessus (Step-Over)."
    },
    {
        "id": "q96",
        "text": "Dans quel contexte utilise-t-on le 'Step-Into' ?",
        "options": [
            { "id": "a", "label": "Pour analyser les fonctions internes inconnues du malware.", "correct": true },
            { "id": "b", "label": "Pour les fonctions système.", "correct": false },
            { "id": "c", "label": "Pour fermer le programme.", "correct": false },
            { "id": "d", "label": "Pour sauter les instructions.", "correct": false }
        ],
        "explanation": "Le Step-Into est nécessaire pour comprendre la logique propre au malware, en entrant dans ses fonctions."
    },
    {
        "id": "q97",
        "text": "Qu'appelle-t-on un programme 'broken' dans le jargon du debugging ?",
        "options": [
            { "id": "a", "label": "Un programme qui a planté.", "correct": false },
            { "id": "b", "label": "Un programme mis en pause à un breakpoint.", "correct": true },
            { "id": "c", "label": "Un programme corrompu.", "correct": false },
            { "id": "d", "label": "Un programme mal compilé.", "correct": false }
        ],
        "explanation": "Le terme vient de 'break' (point d'arrêt), signifiant que l'exécution est suspendue pour analyse."
    },
    {
        "id": "q98",
        "text": "Quelle est l'utilité de mettre un breakpoint juste avant une fonction de chiffrement ?",
        "options": [
            { "id": "a", "label": "Empêcher le chiffrement.", "correct": false },
            { "id": "b", "label": "Capturer les données en clair avant qu'elles ne soient chiffrées.", "correct": true },
            { "id": "c", "label": "Accélérer le chiffrement.", "correct": false },
            { "id": "d", "label": "Supprimer la clé de chiffrement.", "correct": false }
        ],
        "explanation": "Cela permet de voir ce que le malware s'apprête à envoyer ou à cacher (ex: mots de passe, données volées) avant que ce ne soit illisible."
    },
    {
        "id": "q99",
        "text": "Qu'est-ce qu'un breakpoint conditionnel ?",
        "options": [
            { "id": "a", "label": "Un breakpoint qui s'active tout le temps.", "correct": false },
            { "id": "b", "label": "Un breakpoint qui ne s'active que si une condition spécifique est vérifiée par le debugger.", "correct": true },
            { "id": "c", "label": "Un breakpoint aléatoire.", "correct": false },
            { "id": "d", "label": "Un breakpoint qui plante le PC.", "correct": false }
        ],
        "explanation": "Cela évite de devoir appuyer sur 'Continuer' des milliers de fois si l'événement intéressant ne se produit que rarement (ex: paquet réseau spécifique)."
    },
    {
        "id": "q100",
        "text": "Quel mécanisme est utilisé pour implémenter le 'single stepping' (pas à pas) ?",
        "options": [
            { "id": "a", "label": "Le Trap Flag (TF) dans le registre EFLAGS.", "correct": true },
            { "id": "b", "label": "Le Zero Flag.", "correct": false },
            { "id": "c", "label": "L'écran bleu.", "correct": false },
            { "id": "d", "label": "La souris.", "correct": false }
        ],
        "explanation": "Le processeur génère une exception après chaque instruction si le Trap Flag est activé, permettant au debugger de reprendre la main."
    },
    {
        "id": "q101",
        "text": "Qu'est-ce qu'une 'Access Violation' ?",
        "options": [
            { "id": "a", "label": "Une tentative d'accès à un emplacement mémoire non autorisé ou invalide.", "correct": true },
            { "id": "b", "label": "Une erreur de mot de passe.", "correct": false },
            { "id": "c", "label": "Un pare-feu qui bloque une connexion.", "correct": false },
            { "id": "d", "label": "Une erreur de compilation.", "correct": false }
        ],
        "explanation": "C'est une erreur classique quand un programme essaie de lire ou écrire dans une zone mémoire qui ne lui appartient pas."
    },
    {
        "id": "q102",
        "text": "Comment peut-on sauter l'exécution d'une fonction malveillante dans un debugger ?",
        "options": [
            { "id": "a", "label": "En supprimant le fichier.", "correct": false },
            { "id": "b", "label": "En plaçant un breakpoint sur le Call, puis en déplaçant l'instruction suivante (EIP) après le Call.", "correct": true },
            { "id": "c", "label": "En fermant les yeux.", "correct": false },
            { "id": "d", "label": "En redémarrant l'ordinateur.", "correct": false }
        ],
        "explanation": "En modifiant le pointeur d'instruction (EIP) pour qu'il pointe après l'instruction 'Call', le code de la fonction n'est jamais exécuté."
    },
    {
        "id": "q103",
        "text": "Quel est le danger de tester une fonction isolément en l'exécutant manuellement ?",
        "options": [
            { "id": "a", "label": "Cela détruit la stack (pile) du programme en cours.", "correct": true },
            { "id": "b", "label": "Cela ne fait rien.", "correct": false },
            { "id": "c", "label": "Cela répare le programme.", "correct": false },
            { "id": "d", "label": "Cela accélère l'analyse.", "correct": false }
        ],
        "explanation": "Forcer l'exécution d'une fonction modifie l'état de la pile et des registres, rendant souvent la suite de l'exécution du programme instable ou impossible."
    },
    {
        "id": "q104",
        "text": "Dans l'exemple du malware dépendant de la langue, que se passe-t-il si le système est en Anglais ?",
        "options": [
            { "id": "a", "label": "Il s'autodétruit.", "correct": false },
            { "id": "b", "label": "Il affiche un pop-up 'Your luck's no good'.", "correct": true },
            { "id": "c", "label": "Il écrase le disque dur.", "correct": false },
            { "id": "d", "label": "Il ne fait rien.", "correct": false }
        ],
        "explanation": "L'exemple montre une réponse différente selon la langue : l'anglais déclenche une simple moquerie."
    },
    {
        "id": "q105",
        "text": "Dans ce même exemple, quelle action destructrice est réservée aux systèmes Japonais ou Indonésiens ?",
        "options": [
            { "id": "a", "label": "Désinstallation.", "correct": false },
            { "id": "b", "label": "Écrasement du disque dur avec des données aléatoires.", "correct": true },
            { "id": "c", "label": "Envoi de spam.", "correct": false },
            { "id": "d", "label": "Minage de bitcoin.", "correct": false }
        ],
        "explanation": "C'est la charge utile destructrice (payload) qui est activée uniquement pour ces ID de langue spécifiques."
    },
    {
        "id": "q106",
        "text": "Quelle fonction Windows le malware utilise-t-il pour connaître la langue du système ?",
        "options": [
            { "id": "a", "label": "GetLocalTime", "correct": false },
            { "id": "b", "label": "GetSystemDefaultLCID", "correct": true },
            { "id": "c", "label": "OpenProcess", "correct": false },
            { "id": "d", "label": "CreateFile", "correct": false }
        ],
        "explanation": "GetSystemDefaultLCID retourne l'identifiant de locale (Langue/Pays) par défaut du système."
    },
    {
        "id": "q107",
        "text": "Comment l'adresse IP 127.0.0.1 est-elle représentée en Hexadécimal sur le RÉSEAU (Big-endian) ?",
        "options": [
            { "id": "a", "label": "01 00 00 7F", "correct": false },
            { "id": "b", "label": "7F 00 00 01", "correct": true },
            { "id": "c", "label": "FF FF FF FF", "correct": false },
            { "id": "d", "label": "00 00 00 00", "correct": false }
        ],
        "explanation": "Sur le réseau (Big-endian), l'ordre est naturel : 127 (7F) . 0 (00) . 0 (00) . 1 (01)."
    },
    {
        "id": "q108",
        "text": "Quel est le niveau d'abstraction le plus bas après le Hardware ?",
        "options": [
            { "id": "a", "label": "Langage C.", "correct": false },
            { "id": "b", "label": "Microcode (Firmware).", "correct": true },
            { "id": "c", "label": "Assembleur.", "correct": false },
            { "id": "d", "label": "Code machine.", "correct": false }
        ],
        "explanation": "Le microcode est spécifique au matériel et sert d'interface entre le hardware pur et le code machine."
    },
    {
        "id": "q109",
        "text": "De quoi est composé le code machine ?",
        "options": [
            { "id": "a", "label": "D'opcodes (codes opérations).", "correct": true },
            { "id": "b", "label": "De texte anglais.", "correct": false },
            { "id": "c", "label": "De code HTML.", "correct": false },
            { "id": "d", "label": "De pixels.", "correct": false }
        ],
        "explanation": "Le code machine est une suite de valeurs numériques (opcodes) comprises directement par le processeur."
    },
    {
        "id": "q110",
        "text": "Quel niveau de langage sont le C et le C++ ?",
        "options": [
            { "id": "a", "label": "Langage bas niveau.", "correct": false },
            { "id": "b", "label": "Langage haut niveau.", "correct": true },
            { "id": "c", "label": "Langage interprété.", "correct": false },
            { "id": "d", "label": "Microcode.", "correct": false }
        ],
        "explanation": "Le C et C++ sont des langages de haut niveau qui doivent être compilés en code machine."
    },
    {
        "id": "q111",
        "text": "Quel outil permet de calculer des empreintes (hashes) comme MD5 ou SHA1 ?",
        "options": [
            { "id": "a", "label": "HashCalc", "correct": true },
            { "id": "b", "label": "Paint", "correct": false },
            { "id": "c", "label": "Word", "correct": false },
            { "id": "d", "label": "Skype", "correct": false }
        ],
        "explanation": "HashCalc est cité comme un outil permettant de générer les signatures uniques de fichiers."
    },
    {
        "id": "q112",
        "text": "Comment détecter un document malveillant (PDF/Word) avec Process Explorer ?",
        "options": [
            { "id": "a", "label": "En l'ouvrant et en surveillant si un nouveau processus inattendu se lance.", "correct": true },
            { "id": "b", "label": "En regardant la couleur de l'icône.", "correct": false },
            { "id": "c", "label": "En le renommant en .txt.", "correct": false },
            { "id": "d", "label": "C'est impossible.", "correct": false }
        ],
        "explanation": "L'ouverture du document ne devrait lancer que le lecteur (Word/Adobe), si un autre exécutable démarre, c'est suspect."
    },
    {
        "id": "q113",
        "text": "Quelle est une limite majeure de l'analyse statique ?",
        "options": [
            { "id": "a", "label": "Elle est trop rapide.", "correct": false },
            { "id": "b", "label": "Elle est inefficace contre l'obfuscation et le packing.", "correct": true },
            { "id": "c", "label": "Elle casse l'ordinateur.", "correct": false },
            { "id": "d", "label": "Elle nécessite trop de RAM.", "correct": false }
        ],
        "explanation": "Si le code est caché (packed) ou illisible (obfusqué), l'analyse statique ne voit rien d'utile sans décompression préalable."
    },
    {
        "id": "q114",
        "text": "Citez des exemples d'outils de Sandbox (bacs à sable).",
        "options": [
            { "id": "a", "label": "Cuckoo, Joe Sandbox, ThreatExpert.", "correct": true },
            { "id": "b", "label": "Word, Excel, PowerPoint.", "correct": false },
            { "id": "c", "label": "Photoshop, Illustrator.", "correct": false },
            { "id": "d", "label": "Chrome, Firefox.", "correct": false }
        ],
        "explanation": "Ces outils automatisent l'analyse dynamique en environnement isolé."
    },
    {
        "id": "q115",
        "text": "Quel est le registre contenant les drapeaux (Flags) en 32-bits ?",
        "options": [
            { "id": "a", "label": "EIP", "correct": false },
            { "id": "b", "label": "EFLAGS", "correct": true },
            { "id": "c", "label": "EAX", "correct": false },
            { "id": "d", "label": "ESP", "correct": false }
        ],
        "explanation": "EFLAGS contient les indicateurs d'état (Zero, Sign, Overflow, etc.) utilisés pour les sauts conditionnels."
    },
    {
        "id": "q116",
        "text": "Quelle condition vérifie le saut 'JG' (Jump Greater) ou 'JNLE' ?",
        "options": [
            { "id": "a", "label": "ZF=0 et SF=OF (strictement supérieur signé).", "correct": true },
            { "id": "b", "label": "ZF=1.", "correct": false },
            { "id": "c", "label": "CF=1.", "correct": false },
            { "id": "d", "label": "SF=1.", "correct": false }
        ],
        "explanation": "JG saute si la valeur est strictement supérieure (dans une comparaison signée)."
    },
    {
        "id": "q117",
        "text": "Quelle condition vérifie le saut 'JB' (Jump Below) ?",
        "options": [
            { "id": "a", "label": "CF=1 (Retenue activée, inférieur non signé).", "correct": true },
            { "id": "b", "label": "ZF=1.", "correct": false },
            { "id": "c", "label": "OF=1.", "correct": false },
            { "id": "d", "label": "SF=0.", "correct": false }
        ],
        "explanation": "JB est utilisé pour les comparaisons non signées, vérifiant le Carry Flag."
    },
    {
        "id": "q118",
        "text": "Qu'est-ce qu'une 'privilege violation' (violation de privilège) ?",
        "options": [
            { "id": "a", "label": "Une tentative d'exécution d'une instruction Ring 0 (Kernel) depuis le Ring 3 (User).", "correct": true },
            { "id": "b", "label": "Oublier son mot de passe administrateur.", "correct": false },
            { "id": "c", "label": "Utiliser un logiciel piraté.", "correct": false },
            { "id": "d", "label": "Une erreur de disque.", "correct": false }
        ],
        "explanation": "Le processeur empêche le code utilisateur d'exécuter des instructions réservées au noyau pour protéger le système."
    },
    {
        "id": "q119",
        "text": "Quel est l'effet de la commande assembleur 'mov ecx, 0x42' ?",
        "options": [
            { "id": "a", "label": "Elle ajoute 42 à ECX.", "correct": false },
            { "id": "b", "label": "Elle place la valeur hexadécimale 42 dans le registre ECX.", "correct": true },
            { "id": "c", "label": "Elle compare ECX à 42.", "correct": false },
            { "id": "d", "label": "Elle efface ECX.", "correct": false }
        ],
        "explanation": "C'est une instruction de déplacement de données immédiates vers un registre."
    },
    {
        "id": "q120",
        "text": "Quelle est la caractéristique des langages interprétés comme Java ou Python ?",
        "options": [
            { "id": "a", "label": "Ils sont traduits en bytecode, puis exécutés par un interpréteur.", "correct": true },
            { "id": "b", "label": "Ils sont compilés directement en code machine.", "correct": false },
            { "id": "c", "label": "Ils ne fonctionnent pas sur Windows.", "correct": false },
            { "id": "d", "label": "Ils sont du niveau hardware.", "correct": false }
        ],
        "explanation": "Ils passent par une représentation intermédiaire (bytecode) indépendante de la machine, qui est lue par une machine virtuelle (JVM, Python VM)."
    },
    {
        "id": "q121",
        "text": "Outre l'identification et la destruction du malware, à quoi sert l'analyse de malware dans la réponse à incident ?",
        "options": [
            { "id": "a", "label": "À augmenter la vitesse du réseau.", "correct": false },
            { "id": "b", "label": "À comprendre ce qu'il s'est passé, identifier les machines touchées et contenir les dommages.", "correct": true },
            { "id": "c", "label": "À réinstaller Windows.", "correct": false },
            { "id": "d", "label": "À créer des virus.", "correct": false }
        ],
        "explanation": "L'analyse sert à comprendre le fonctionnement pour mesurer l'étendue de l'incident et créer des signatures."
    },
    {
        "id": "q122",
        "text": "Quel outil est spécifiquement cité pour l'analyse de la RAM (mémoire vive) aux côtés de Volatility ?",
        "options": [
            { "id": "a", "label": "Mandiant Redline", "correct": true },
            { "id": "b", "label": "Notepad++", "correct": false },
            { "id": "c", "label": "CPU-Z", "correct": false },
            { "id": "d", "label": "Adobe Reader", "correct": false }
        ],
        "explanation": "Mandiant Redline est mentionné comme un outil d'analyse dynamique pour la RAM."
    },
    {
        "id": "q123",
        "text": "Quelle est la définition d'un 'Targeted malware' (malware ciblé) ?",
        "options": [
            { "id": "a", "label": "Un malware qui cible une infrastructure ou une personne spécifique (ex: Stuxnet).", "correct": true },
            { "id": "b", "label": "Un malware qui cible tout le monde.", "correct": false },
            { "id": "c", "label": "Un malware qui ne fonctionne pas.", "correct": false },
            { "id": "d", "label": "Un malware vendu sur eBay.", "correct": false }
        ],
        "explanation": "Le malware ciblé vise une cible spécifique et nécessite souvent une analyse avancée du système cible."
    },
    {
        "id": "q124",
        "text": "Quelle est la taille d'un caractère 'wide character' en Unicode ?",
        "options": [
            { "id": "a", "label": "1 octet.", "correct": false },
            { "id": "b", "label": "2 octets.", "correct": true },
            { "id": "c", "label": "4 octets.", "correct": false },
            { "id": "d", "label": "8 octets.", "correct": false }
        ],
        "explanation": "Les 'wide characters' du format Unicode occupent 2 octets."
    },
    {
        "id": "q125",
        "text": "Qu'est-ce que 'UPX' ?",
        "options": [
            { "id": "a", "label": "Un protocole réseau.", "correct": false },
            { "id": "b", "label": "Un packer d'exécutables (Ultimate Packer for Executables).", "correct": true },
            { "id": "c", "label": "Un type de processeur.", "correct": false },
            { "id": "d", "label": "Une marque d'antivirus.", "correct": false }
        ],
        "explanation": "UPX est une signature courante trouvée dans l'en-tête des fichiers packés."
    },
    {
        "id": "q126",
        "text": "Quel problème peut survenir avec les plugins de PEID ?",
        "options": [
            { "id": "a", "label": "Ils peuvent exécuter le malware accidentellement.", "correct": true },
            { "id": "b", "label": "Ils sont trop chers.", "correct": false },
            { "id": "c", "label": "Ils ne fonctionnent que sur Linux.", "correct": false },
            { "id": "d", "label": "Ils suppriment le fichier.", "correct": false }
        ],
        "explanation": "Certains plugins PEID peuvent exécuter le code malveillant, et des failles dans les outils d'analyse peuvent permettre au malware de s'échapper."
    },
    {
        "id": "q127",
        "text": "Que contient l'en-tête PE (PE Header) en termes de besoins mémoire ?",
        "options": [
            { "id": "a", "label": "La couleur des fenêtres.", "correct": false },
            { "id": "b", "label": "Les besoins en mémoire du programme (Virtual Size).", "correct": true },
            { "id": "c", "label": "L'historique de navigation.", "correct": false },
            { "id": "d", "label": "Le nom de l'utilisateur.", "correct": false }
        ],
        "explanation": "Le PE header contient les métadonnées essentielles, dont les besoins en mémoire pour l'exécution."
    },
    {
        "id": "q128",
        "text": "Quel est l'inconvénient principal de la liaison statique (static linking) pour l'exécutable ?",
        "options": [
            { "id": "a", "label": "L'exécutable devient très volumineux car il copie tout le code de la bibliothèque.", "correct": true },
            { "id": "b", "label": "L'exécutable ne se lance pas.", "correct": false },
            { "id": "c", "label": "C'est illégal.", "correct": false },
            { "id": "d", "label": "Cela nécessite Internet.", "correct": false }
        ],
        "explanation": "Tout le code de la bibliothèque est copié dans le .exe, ce qui augmente considérablement sa taille."
    },
    {
        "id": "q129",
        "text": "Quel inconvénient présente l'utilisation d'une Machine Virtuelle (VM) pour l'analyse ?",
        "options": [
            { "id": "a", "label": "Elle est trop rapide.", "correct": false },
            { "id": "b", "label": "Certains malwares détectent qu'ils sont dans une VM et faussent les résultats.", "correct": true },
            { "id": "c", "label": "Elle ne peut pas lancer de .exe.", "correct": false },
            { "id": "d", "label": "Elle coûte très cher.", "correct": false }
        ],
        "explanation": "Les malwares peuvent détecter l'environnement virtuel et changer leur comportement (anti-vm)."
    },
    {
        "id": "q130",
        "text": "Quelle méthode de filtrage est recommandée dans Process Monitor pour éviter de masquer l'activité du malware ?",
        "options": [
            { "id": "a", "label": "Exclude (Exclure).", "correct": false },
            { "id": "b", "label": "Include (Inclure).", "correct": true },
            { "id": "c", "label": "Delete (Supprimer).", "correct": false },
            { "id": "d", "label": "Block (Bloquer).", "correct": false }
        ],
        "explanation": "L'exclusion risque de cacher une activité malveillante injectée dans un processus normal ; il vaut mieux filtrer par inclusion."
    },
    {
        "id": "q131",
        "text": "Que signifie l'acronyme DEP visible dans Process Explorer ?",
        "options": [
            { "id": "a", "label": "Data Execution Prevention.", "correct": true },
            { "id": "b", "label": "Data Entry Point.", "correct": false },
            { "id": "c", "label": "Digital Encryption Protocol.", "correct": false },
            { "id": "d", "label": "Dynamic Entry Process.", "correct": false }
        ],
        "explanation": "DEP est une mesure de sécurité affichée dans l'onglet Images de Process Explorer."
    },
    {
        "id": "q132",
        "text": "Quelle est la procédure correcte pour utiliser RegShot ?",
        "options": [
            { "id": "a", "label": "Lancer le malware, puis faire un snapshot.", "correct": false },
            { "id": "b", "label": "Prendre un snapshot (shot 1), lancer le malware, prendre un second snapshot (shot 2), comparer.", "correct": true },
            { "id": "c", "label": "Comparer deux PC différents.", "correct": false },
            { "id": "d", "label": "Regarder le registre manuellement.", "correct": false }
        ],
        "explanation": "Regshot fonctionne par comparaison d'états : avant (shot 1) et après (shot 2) l'infection."
    },
    {
        "id": "q133",
        "text": "Quel est le niveau d'abstraction correspondant aux portes logiques (AND, OR, XOR) ?",
        "options": [
            { "id": "a", "label": "Hardware.", "correct": true },
            { "id": "b", "label": "Microcode.", "correct": false },
            { "id": "c", "label": "Code machine.", "correct": false },
            { "id": "d", "label": "Assembleur.", "correct": false }
        ],
        "explanation": "Le niveau Hardware est composé de circuits électroniques et de portes logiques."
    },
    {
        "id": "q134",
        "text": "Quel langage est considéré comme le plus haut niveau fiable pour analyser un malware sans code source ?",
        "options": [
            { "id": "a", "label": "C++.", "correct": false },
            { "id": "b", "label": "Java.", "correct": false },
            { "id": "c", "label": "Langage assembleur.", "correct": true },
            { "id": "d", "label": "Code machine.", "correct": false }
        ],
        "explanation": "L'assembleur est la représentation lisible la plus fiable lorsqu'on n'a pas le code source."
    },
    {
        "id": "q135",
        "text": "Quelle valeur hexadécimale représente l'instruction 'mov ecx' ?",
        "options": [
            { "id": "a", "label": "0x90", "correct": false },
            { "id": "b", "label": "0xB9", "correct": true },
            { "id": "c", "label": "0xCC", "correct": false },
            { "id": "d", "label": "0x42", "correct": false }
        ],
        "explanation": "L'exemple du cours indique que 'mov ecx' correspond à l'opcode 0xB9."
    },
    {
        "id": "q136",
        "text": "Si 'mov ecx 0x42' est traduit en binaire par 0xB942000000, quel est le format de la valeur 0x42 ?",
        "options": [
            { "id": "a", "label": "Big-endian.", "correct": false },
            { "id": "b", "label": "Little-endian (42 00 00 00).", "correct": true },
            { "id": "c", "label": "ASCII.", "correct": false },
            { "id": "d", "label": "Unicode.", "correct": false }
        ],
        "explanation": "La valeur 0x42 est stockée comme 42 00 00 00 en mémoire sur une architecture x86 (Little-endian)."
    },
    {
        "id": "q137",
        "text": "Quelle condition déclenche le saut 'JS' (Jump if Sign) ?",
        "options": [
            { "id": "a", "label": "SF=1 (Sign Flag activé, résultat négatif).", "correct": true },
            { "id": "b", "label": "ZF=1.", "correct": false },
            { "id": "c", "label": "OF=1.", "correct": false },
            { "id": "d", "label": "CF=0.", "correct": false }
        ],
        "explanation": "JS saute si le Sign Flag (SF) est égal à 1."
    },
    {
        "id": "q138",
        "text": "Quelle condition déclenche le saut 'JO' (Jump if Overflow) ?",
        "options": [
            { "id": "a", "label": "OF=1 (Overflow Flag activé).", "correct": true },
            { "id": "b", "label": "ZF=0.", "correct": false },
            { "id": "c", "label": "SF=1.", "correct": false },
            { "id": "d", "label": "CF=1.", "correct": false }
        ],
        "explanation": "JO saute si l'Overflow Flag (OF) est égal à 1."
    },
    {
        "id": "q139",
        "text": "Qu'est-ce qu'un 'source-level debugger' ?",
        "options": [
            { "id": "a", "label": "Un debugger qui fonctionne sur le code assembleur uniquement.", "correct": false },
            { "id": "b", "label": "Un debugger intégré aux environnements de développement qui utilise le code source.", "correct": true },
            { "id": "c", "label": "Un outil pour hacker.", "correct": false },
            { "id": "d", "label": "Un debugger kernel.", "correct": false }
        ],
        "explanation": "Le source-level debugger permet de debugger ligne par ligne le code source original lors du développement."
    },
    {
        "id": "q140",
        "text": "Quel est l'avantage de démarrer un programme DIRECTEMENT avec le debugger (au lieu de l'attacher) ?",
        "options": [
            { "id": "a", "label": "On peut observer l'initialisation du programme et repérer les techniques anti-debug.", "correct": true },
            { "id": "b", "label": "C'est plus rapide.", "correct": false },
            { "id": "c", "label": "Cela évite de planter.", "correct": false },
            { "id": "d", "label": "On n'a pas besoin de droits administrateur.", "correct": false }
        ],
        "explanation": "Lancer avec le debugger permet de contrôler l'exécution dès la première instruction (Entry Point)."
    },
    {
        "id": "q141",
        "text": "Combien de registres de debug (DRx) sont utilisés pour stocker les adresses des breakpoints matériels ?",
        "options": [
            { "id": "a", "label": "2", "correct": false },
            { "id": "b", "label": "4 (DR0 à DR3).", "correct": true },
            { "id": "c", "label": "8", "correct": false },
            { "id": "d", "label": "16", "correct": false }
        ],
        "explanation": "L'exécution matérielle utilise 4 registres de debug (DR0 à DR3) pour les adresses."
    },
    {
        "id": "q142",
        "text": "Si un debugger reçoit une exception de première chance, que peut-il faire ?",
        "options": [
            { "id": "a", "label": "Il doit obligatoirement arrêter le programme.", "correct": false },
            { "id": "b", "label": "La gérer lui-même ou la transmettre au programme (pass exception).", "correct": true },
            { "id": "c", "label": "Il doit redémarrer Windows.", "correct": false },
            { "id": "d", "label": "Il supprime le code fautif.", "correct": false }
        ],
        "explanation": "Le debugger a le choix : traiter l'exception ou la laisser au gestionnaire d'exception de l'application."
    },
    {
        "id": "q143",
        "text": "Quelle exception est générée par les breakpoints logiciels ?",
        "options": [
            { "id": "a", "label": "INT 1", "correct": false },
            { "id": "b", "label": "INT 3", "correct": true },
            { "id": "c", "label": "INT 80", "correct": false },
            { "id": "d", "label": "Page Fault", "correct": false }
        ],
        "explanation": "INT 3 est l'interruption spécifique pour les breakpoints logiciels."
    },
    {
        "id": "q144",
        "text": "Quel flag est utilisé pour le 'Single Stepping' (mode pas à pas) ?",
        "options": [
            { "id": "a", "label": "Trap Flag.", "correct": true },
            { "id": "b", "label": "Zero Flag.", "correct": false },
            { "id": "c", "label": "Carry Flag.", "correct": false },
            { "id": "d", "label": "Direction Flag.", "correct": false }
        ],
        "explanation": "Le Trap Flag, lorsqu'il est défini, génère une exception après chaque instruction pour permettre le pas à pas."
    },
    {
        "id": "q145",
        "text": "Quelle est la conséquence de sauter une fonction (en modifiant EIP) qui effectuait une initialisation de variable ?",
        "options": [
            { "id": "a", "label": "Le programme risque de crasher ou de dysfonctionner.", "correct": true },
            { "id": "b", "label": "Le programme ira plus vite.", "correct": false },
            { "id": "c", "label": "La variable sera initialisée à 0 automatiquement.", "correct": false },
            { "id": "d", "label": "Rien de grave.", "correct": false }
        ],
        "explanation": "Si une fonction critique (comme une init) est sautée, la suite du programme opérera sur des données invalides."
    },
    {
        "id": "q146",
        "text": "Dans l'exemple du malware dépendant de la langue, quelle est la valeur Hexa pour 'English' ?",
        "options": [
            { "id": "a", "label": "0x409", "correct": true },
            { "id": "b", "label": "0x411", "correct": false },
            { "id": "c", "label": "0x421", "correct": false },
            { "id": "d", "label": "0xC04", "correct": false }
        ],
        "explanation": "L'identifiant 409h correspond à l'Anglais dans le code analysé."
    },
    {
        "id": "q147",
        "text": "Quelle valeur Hexa correspond au Chinois dans l'exemple du malware ?",
        "options": [
            { "id": "a", "label": "0xC04", "correct": true },
            { "id": "b", "label": "0x409", "correct": false },
            { "id": "c", "label": "0x411", "correct": false },
            { "id": "d", "label": "0x421", "correct": false }
        ],
        "explanation": "C04h est l'identifiant pour le Chinois, qui déclenche la désinstallation."
    },
    {
        "id": "q148",
        "text": "Pourquoi modifier le registre EAX (valeur de retour) après l'appel à GetSystemDefaultLCID dans le cas pratique ?",
        "options": [
            { "id": "a", "label": "Pour changer la langue du clavier.", "correct": false },
            { "id": "b", "label": "Pour simuler une autre langue et observer la réaction du malware (ex: autodestruction).", "correct": true },
            { "id": "c", "label": "Pour accélérer le programme.", "correct": false },
            { "id": "d", "label": "Pour contourner l'antivirus.", "correct": false }
        ],
        "explanation": "En forçant la valeur de retour, on trompe le malware sur l'environnement d'exécution pour analyser ses différentes branches de code."
    },
    {
        "id": "q149",
        "text": "Que fait un 'Launcher' en théorie ?",
        "options": [
            { "id": "a", "label": "Il suppose que le programme malveillant est déjà sur la machine et le lance.", "correct": true },
            { "id": "b", "label": "Il le télécharge.", "correct": false },
            { "id": "c", "label": "Il le crypte.", "correct": false },
            { "id": "d", "label": "Il l'efface.", "correct": false }
        ],
        "explanation": "Le launcher est un exécutable qui sert à démarrer un autre code malveillant déjà présent."
    },
    {
        "id": "q150",
        "text": "Quel type de signature est plus efficace lorsqu'elle est créée APRES l'analyse du malware ?",
        "options": [
            { "id": "a", "label": "Signature réseau.", "correct": true },
            { "id": "b", "label": "Signature papier.", "correct": false },
            { "id": "c", "label": "Signature numérique.", "correct": false },
            { "id": "d", "label": "Signature antivirus.", "correct": false }
        ],
        "explanation": "Les signatures réseau sont plus efficaces quand elles sont créées après avoir analysé le comportement du malware."
    }
]