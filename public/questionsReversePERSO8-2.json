[
    {
        "id": "q1",
        "text": "Quelle instruction assembleur est utilisée pour déclencher un appel système (syscall) sous Linux x86_64 ?",
        "options": [
            { "id": "a", "label": "INT 0x80", "correct": false },
            { "id": "b", "label": "CALL", "correct": false },
            { "id": "c", "label": "SYSCALL", "correct": true },
            { "id": "d", "label": "SYSENTER", "correct": false }
        ],
        "explanation": "Le tableau 'x86_64 Linux Syscall Structure' indique explicitement que l'instruction est SYSCALL."
    },
    {
        "id": "q2",
        "text": "Dans quel registre doit-on placer le numéro de l'appel système (Syscall #) avant l'instruction SYSCALL ?",
        "options": [
            { "id": "a", "label": "rdi", "correct": false },
            { "id": "b", "label": "rax", "correct": true },
            { "id": "c", "label": "rsi", "correct": false },
            { "id": "d", "label": "rdx", "correct": false }
        ],
        "explanation": "La colonne 'Syscall #' du tableau de structure indique le registre rax."
    },
    {
        "id": "q3",
        "text": "Quel registre contient la valeur de retour après un appel système sous Linux x86_64 ?",
        "options": [
            { "id": "a", "label": "rax", "correct": true },
            { "id": "b", "label": "rbx", "correct": false },
            { "id": "c", "label": "rcx", "correct": false },
            { "id": "d", "label": "rdx", "correct": false }
        ],
        "explanation": "La colonne 'Return Value' du tableau de structure désigne le registre rax."
    },
    {
        "id": "q4",
        "text": "Quel est le registre utilisé pour le premier argument (arg0) d'un appel système Linux x86_64 ?",
        "options": [
            { "id": "a", "label": "rsi", "correct": false },
            { "id": "b", "label": "rdx", "correct": false },
            { "id": "c", "label": "rax", "correct": false },
            { "id": "d", "label": "rdi", "correct": true }
        ],
        "explanation": "La colonne 'arg0' du tableau de structure correspond au registre rdi."
    },
    {
        "id": "q5",
        "text": "Quel est le numéro de l'appel système `sys_write` ?",
        "options": [
            { "id": "a", "label": "0", "correct": false },
            { "id": "b", "label": "1", "correct": true },
            { "id": "c", "label": "2", "correct": false },
            { "id": "d", "label": "3", "correct": false }
        ],
        "explanation": "Dans la 'x86_64 Linux Syscall Table', la ligne pour sys_write indique la valeur 1 dans la colonne rax."
    },
    {
        "id": "q6",
        "text": "Quels sont les arguments attendus par l'appel système `sys_open` ?",
        "options": [
            { "id": "a", "label": "unsigned int fd, char* buf, size_t count", "correct": false },
            { "id": "b", "label": "const char* filename, int flags, int mode", "correct": true },
            { "id": "c", "label": "unsigned int fd", "correct": false },
            { "id": "d", "label": "int mode, int flags", "correct": false }
        ],
        "explanation": "La table des syscalls liste pour `sys_open` : filename (rdi), flags (rsi), et mode (rdx)."
    },
    {
        "id": "q7",
        "text": "À quel appel système correspond la valeur 0 dans le registre rax ?",
        "options": [
            { "id": "a", "label": "sys_read", "correct": true },
            { "id": "b", "label": "sys_write", "correct": false },
            { "id": "c", "label": "sys_open", "correct": false },
            { "id": "d", "label": "sys_close", "correct": false }
        ],
        "explanation": "La première ligne de la table des syscalls associe la valeur 0 à `sys_read`."
    },
    {
        "id": "q8",
        "text": "Quel registre est utilisé pour passer le 2ème argument (arg1) à un syscall ?",
        "options": [
            { "id": "a", "label": "rdi", "correct": false },
            { "id": "b", "label": "rdx", "correct": false },
            { "id": "c", "label": "rsi", "correct": true },
            { "id": "d", "label": "r10", "correct": false }
        ],
        "explanation": "La colonne 'arg1' du tableau de structure indique le registre rsi."
    },
    {
        "id": "q9",
        "text": "Dans GDB, quelle commande permet d'afficher les 32 instructions suivant le pointeur d'instruction ($rip) ?",
        "options": [
            { "id": "a", "label": "x/32x $rip", "correct": false },
            { "id": "b", "label": "disass $rip", "correct": false },
            { "id": "c", "label": "x/32i $rip", "correct": true },
            { "id": "d", "label": "show instructions", "correct": false }
        ],
        "explanation": "L'image des commandes GDB liste explicitement `x/32i $rip` pour afficher les 32 instructions après $rip."
    },
    {
        "id": "q10",
        "text": "Quelle commande GDB permet d'ajouter un argument au programme avant son exécution ?",
        "options": [
            { "id": "a", "label": "add args", "correct": false },
            { "id": "b", "label": "set args", "correct": true },
            { "id": "c", "label": "args set", "correct": false },
            { "id": "d", "label": "input", "correct": false }
        ],
        "explanation": "La commande `set args` est définie comme 'on ajoute un argument au programme'."
    },
    {
        "id": "q11",
        "text": "Quelle est la différence entre les commandes `ni` et `si` dans GDB ?",
        "options": [
            { "id": "a", "label": "`ni` entre dans les appels de fonction, `si` passe à la suivante", "correct": false },
            { "id": "b", "label": "`ni` est pour Intel, `si` pour AT&T", "correct": false },
            { "id": "c", "label": "`ni` passe à l'instruction suivante (step over), `si` suit les appels (step into)", "correct": true },
            { "id": "d", "label": "Il n'y a aucune différence", "correct": false }
        ],
        "explanation": "Le cours indique que `ni` exécute l'instruction courante et passe à la suivante, tandis que `si` est pareil que ni mais 'l'exécution suit les appels'."
    },
    {
        "id": "q12",
        "text": "Quelle commande GDB permet d'afficher la chaîne de caractères pointée par le registre RSI ?",
        "options": [
            { "id": "a", "label": "p $rsi", "correct": false },
            { "id": "b", "label": "x/s $rsi", "correct": true },
            { "id": "c", "label": "disp $rsi", "correct": false },
            { "id": "d", "label": "x/c $rsi", "correct": false }
        ],
        "explanation": "La commande `x/s $rsi` est listée avec la description 'on affiche la chaîne de caractère pointée par $rsi'."
    },
    {
        "id": "q13",
        "text": "Comment afficher la liste des breakpoints posés dans GDB ?",
        "options": [
            { "id": "a", "label": "show break", "correct": false },
            { "id": "b", "label": "list b", "correct": false },
            { "id": "c", "label": "i b", "correct": true },
            { "id": "d", "label": "info points", "correct": false }
        ],
        "explanation": "La commande `i b` est indiquée pour 'on affiche la liste des breakpoints posés'."
    },
    {
        "id": "q14",
        "text": "Quelle commande GDB permet de changer la syntaxe de désassemblage pour le format Intel ?",
        "options": [
            { "id": "a", "label": "set syntax intel", "correct": false },
            { "id": "b", "label": "set disassembly-flavor intel", "correct": true },
            { "id": "c", "label": "format intel", "correct": false },
            { "id": "d", "label": "intel_syntax on", "correct": false }
        ],
        "explanation": "La commande exacte listée est `set disassembly-flavor intel`."
    },
    {
        "id": "q15",
        "text": "Quelle commande GDB affiche la pile d'appels (call stack) ?",
        "options": [
            { "id": "a", "label": "stack", "correct": false },
            { "id": "b", "label": "trace", "correct": false },
            { "id": "c", "label": "bt", "correct": true },
            { "id": "d", "label": "cs", "correct": false }
        ],
        "explanation": "La commande `bt` est décrite comme 'on affiche la call stack'."
    },
    {
        "id": "q16",
        "text": "Dans la syntaxe AT&T, quel est l'ordre des opérandes ?",
        "options": [
            { "id": "a", "label": "destination, source", "correct": false },
            { "id": "b", "label": "source, destination", "correct": true },
            { "id": "c", "label": "registre, mémoire", "correct": false },
            { "id": "d", "label": "valeur, adresse", "correct": false }
        ],
        "explanation": "Le tableau de comparaison des syntaxes indique pour AT&T : 'source, destination'."
    },
    {
        "id": "q17",
        "text": "Quelle syntaxe utilise le symbole '%' avant les noms des registres ?",
        "options": [
            { "id": "a", "label": "Intel", "correct": false },
            { "id": "b", "label": "Microsoft", "correct": false },
            { "id": "c", "label": "AT&T", "correct": true },
            { "id": "d", "label": "ARM", "correct": false }
        ],
        "explanation": "Le tableau indique que la syntaxe AT&T met '% avant les noms des registres'."
    },
    {
        "id": "q18",
        "text": "Quelle syntaxe est utilisée par défaut par Microsoft ?",
        "options": [
            { "id": "a", "label": "AT&T", "correct": false },
            { "id": "b", "label": "Intel", "correct": true },
            { "id": "c", "label": "Unix", "correct": false },
            { "id": "d", "label": "SysV", "correct": false }
        ],
        "explanation": "Le tableau associe la syntaxe Intel à Microsoft."
    },
    {
        "id": "q19",
        "text": "Que signifie l'acronyme ISA ?",
        "options": [
            { "id": "a", "label": "Intel System Architecture", "correct": false },
            { "id": "b", "label": "Instruction Set Architecture", "correct": true },
            { "id": "c", "label": "Internal System Access", "correct": false },
            { "id": "d", "label": "Inter-Service Agreement", "correct": false }
        ],
        "explanation": "Le cours définit ISA comme 'Instruction Set Architecture'."
    },
    {
        "id": "q20",
        "text": "Quel type d'architecture possède environ 200 instructions et est utilisé dans l'embarqué ?",
        "options": [
            { "id": "a", "label": "CISC", "correct": false },
            { "id": "b", "label": "x86-64", "correct": false },
            { "id": "c", "label": "RISC", "correct": true },
            { "id": "d", "label": "AMD", "correct": false }
        ],
        "explanation": "La section 'jeux d'instruction' décrit RISC comme possédant environ 200 instructions et utilisé dans l'embarqué."
    },
    {
        "id": "q21",
        "text": "Quel type d'architecture est le x86-64 ?",
        "options": [
            { "id": "a", "label": "RISC", "correct": false },
            { "id": "b", "label": "ARM", "correct": false },
            { "id": "c", "label": "CISC", "correct": true },
            { "id": "d", "label": "MIPS", "correct": false }
        ],
        "explanation": "Le cours classe x86-64 (créé par AMD) dans la catégorie CISC."
    },
    {
        "id": "q22",
        "text": "Quel symbole précède les constantes (valeurs immédiates) dans la syntaxe AT&T ?",
        "options": [
            { "id": "a", "label": "#", "correct": false },
            { "id": "b", "label": "%", "correct": false },
            { "id": "c", "label": "$", "correct": true },
            { "id": "d", "label": "@", "correct": false }
        ],
        "explanation": "Le tableau indique pour AT&T : '$ avant les constantes'."
    },
    {
        "id": "q23",
        "text": "Quels registres sont associés à l'architecture RISC (arm64) dans le cours ?",
        "options": [
            { "id": "a", "label": "RAX, RBX", "correct": false },
            { "id": "b", "label": "EAX, ECX", "correct": false },
            { "id": "c", "label": "X0, X29", "correct": true },
            { "id": "d", "label": "RDI, RSI", "correct": false }
        ],
        "explanation": "Le cours mentionne 'utilise les registres X0, X29 etc..' pour RISC : arm64."
    },
    {
        "id": "q24",
        "text": "Quel est l'ordre des arguments de fonction sous Linux (ABI sysV) ?",
        "options": [
            { "id": "a", "label": "RCX-RDX-R8-R9", "correct": false },
            { "id": "b", "label": "RDI-RSI-RDX-RCX-R8-R9-stack", "correct": true },
            { "id": "c", "label": "RAX-RBX-RCX-RDX", "correct": false },
            { "id": "d", "label": "Stack uniquement", "correct": false }
        ],
        "explanation": "La section 'en gros' liste l'ordre des arguments en linux : RDI-RSI-RDX-RCX-R8-R9-stack."
    },
    {
        "id": "q25",
        "text": "Quel est l'ordre des arguments de fonction sous Windows ?",
        "options": [
            { "id": "a", "label": "RDI-RSI-RDX-RCX", "correct": false },
            { "id": "b", "label": "RCX-RDX-R8-R9", "correct": true },
            { "id": "c", "label": "R0-R1-R2-R3", "correct": false },
            { "id": "d", "label": "EAX-EBX-ECX-EDX", "correct": false }
        ],
        "explanation": "La section 'en gros' liste l'ordre des arguments en windows : RCX-RDX-R8-R9."
    },
    {
        "id": "q26",
        "text": "Que signifie ABI ?",
        "options": [
            { "id": "a", "label": "Abstract Binary Interface", "correct": false },
            { "id": "b", "label": "Application Binary Instruction", "correct": false },
            { "id": "c", "label": "Application Binary Interface", "correct": true },
            { "id": "d", "label": "Advanced Basic Interface", "correct": false }
        ],
        "explanation": "Le cours définit ABI comme 'Application Binary Interface'."
    },
    {
        "id": "q27",
        "text": "Quel format de binaire est produit par le compilateur pour Linux ?",
        "options": [
            { "id": "a", "label": "PE", "correct": false },
            { "id": "b", "label": "mach-O", "correct": false },
            { "id": "c", "label": "ELF", "correct": true },
            { "id": "d", "label": "EXE", "correct": false }
        ],
        "explanation": "Le diagramme de compilation associe 'Linux' au format 'ELF'."
    },
    {
        "id": "q28",
        "text": "Quel format de binaire est produit pour Windows ?",
        "options": [
            { "id": "a", "label": "ELF", "correct": false },
            { "id": "b", "label": "PE", "correct": true },
            { "id": "c", "label": "mach-O", "correct": false },
            { "id": "d", "label": "COFF", "correct": false }
        ],
        "explanation": "Le diagramme de compilation associe 'Windows' au format 'PE'."
    },
    {
        "id": "q29",
        "text": "Quel est le nom de l'ABI utilisée par Linux ?",
        "options": [
            { "id": "a", "label": "ms", "correct": false },
            { "id": "b", "label": "sysV", "correct": true },
            { "id": "c", "label": "cdecl", "correct": false },
            { "id": "d", "label": "stdcall", "correct": false }
        ],
        "explanation": "Le cours mentionne 'On a par exemple sysV pour Linux'."
    },
    {
        "id": "q30",
        "text": "Quelle est la taille d'un 'long' sous Linux (modèle LP64) ?",
        "options": [
            { "id": "a", "label": "4 octets", "correct": false },
            { "id": "b", "label": "8 octets", "correct": true },
            { "id": "c", "label": "16 octets", "correct": false },
            { "id": "d", "label": "2 octets", "correct": false }
        ],
        "explanation": "La section 'le modèle de données' précise : 'Un long vaut 8 octets sous Linux'."
    },
    {
        "id": "q31",
        "text": "Quelle est la taille d'un 'long' sous Windows (modèle LLP64) ?",
        "options": [
            { "id": "a", "label": "8 octets", "correct": false },
            { "id": "b", "label": "2 octets", "correct": false },
            { "id": "c", "label": "4 octets", "correct": true },
            { "id": "d", "label": "10 octets", "correct": false }
        ],
        "explanation": "La section 'le modèle de données' précise : 'mais vaut 4 octets sous Windows'."
    },
    {
        "id": "q32",
        "text": "Quels sont les trois éléments principaux du contexte de compilation ?",
        "options": [
            { "id": "a", "label": "Le langage, le code source, le loader", "correct": false },
            { "id": "b", "label": "L'architecture, l'interface binaire, le modèle de données", "correct": true },
            { "id": "c", "label": "Le processeur, la RAM, le disque dur", "correct": false },
            { "id": "d", "label": "Linux, Windows, iPhone", "correct": false }
        ],
        "explanation": "Le cours liste sous 'contexte de compilation' : a) l'architecture (ISA), b) l'interface binaire, c) le modèle de données."
    },
    {
        "id": "q33",
        "text": "Quel compilateur est associé à Windows dans le schéma ?",
        "options": [
            { "id": "a", "label": "gcc", "correct": false },
            { "id": "b", "label": "clang", "correct": false },
            { "id": "c", "label": "cl", "correct": true },
            { "id": "d", "label": "g++", "correct": false }
        ],
        "explanation": "Le schéma montre 'cl' pointant vers 'Windows (PE)'."
    },
    {
        "id": "q34",
        "text": "Quel compilateur est associé à Linux dans le schéma ?",
        "options": [
            { "id": "a", "label": "gcc", "correct": true },
            { "id": "b", "label": "cl", "correct": false },
            { "id": "c", "label": "msvc", "correct": false },
            { "id": "d", "label": "turbo c", "correct": false }
        ],
        "explanation": "Le schéma montre 'gcc' pointant vers 'Linux (ELF)'."
    },
    {
        "id": "q35",
        "text": "À quoi sert l'ABI ?",
        "options": [
            { "id": "a", "label": "À définir la vitesse du processeur", "correct": false },
            { "id": "b", "label": "À permettre à différentes unités binaires de fonctionner ensemble", "correct": true },
            { "id": "c", "label": "À compiler le code source", "correct": false },
            { "id": "d", "label": "À écrire le code source", "correct": false }
        ],
        "explanation": "La définition donnée est : 'ensemble de conventions qui permet à différentes unités binaires de fonctionner ensemble'."
    },
    {
        "id": "q36",
        "text": "Pourquoi deux codes en x86-64 n'utilisent-ils pas forcément les mêmes registres pour les mêmes tâches ?",
        "options": [
            { "id": "a", "label": "Car ils ont des ABI différentes (ex: sysV vs ms)", "correct": true },
            { "id": "b", "label": "Car l'ISA est différente", "correct": false },
            { "id": "c", "label": "Car le processeur change aléatoirement", "correct": false },
            { "id": "d", "label": "C'est impossible, ils utilisent toujours les mêmes registres", "correct": false }
        ],
        "explanation": "Le cours explique : 'C'est pour cela que deux codes en x86-64 n'utilisent pas les mêmes registres... On a par exemple sysV pour Linux et ms pour Windows'."
    },
    {
        "id": "q37",
        "text": "Dans GDB, quelle commande affiche le layout mémoire (sections) ?",
        "options": [
            { "id": "a", "label": "show memory", "correct": false },
            { "id": "b", "label": "maintenance info sections", "correct": true },
            { "id": "c", "label": "info mem", "correct": false },
            { "id": "d", "label": "display layout", "correct": false }
        ],
        "explanation": "La commande `maintenance info sections` est listée pour 'on affiche une partie du layout mémoire'."
    },
    {
        "id": "q38",
        "text": "Quelle commande GDB permet de continuer l'exécution après un breakpoint ?",
        "options": [
            { "id": "a", "label": "next", "correct": false },
            { "id": "b", "label": "step", "correct": false },
            { "id": "c", "label": "continue", "correct": true },
            { "id": "d", "label": "go", "correct": false }
        ],
        "explanation": "La commande `continue` est décrite comme 'on continue l'exécution après un breakpoint'."
    },
    {
        "id": "q39",
        "text": "Quelle commande GDB permet d'assigner la valeur 0x1337 au registre rax ?",
        "options": [
            { "id": "a", "label": "mov $rax, 0x1337", "correct": false },
            { "id": "b", "label": "set $rax=0x1337", "correct": true },
            { "id": "c", "label": "$rax = 0x1337", "correct": false },
            { "id": "d", "label": "assign 0x1337 to $rax", "correct": false }
        ],
        "explanation": "L'exemple donné est `set $rax=0x1337`."
    },
    {
        "id": "q40",
        "text": "Quelle commande GDB permet de désassembler une fonction spécifique ?",
        "options": [
            { "id": "a", "label": "show function", "correct": false },
            { "id": "b", "label": "disass <function>", "correct": true },
            { "id": "c", "label": "x/i <function>", "correct": false },
            { "id": "d", "label": "list <function>", "correct": false }
        ],
        "explanation": "La commande `disass <function>` est indiquée pour 'on désassemble la fonction <function>'."
    },
    {
        "id": "q41",
        "text": "Dans le tableau des syscalls, quel est le 3ème argument (arg2) pour `sys_write` ?",
        "options": [
            { "id": "a", "label": "char* buf", "correct": false },
            { "id": "b", "label": "unsigned int fd", "correct": false },
            { "id": "c", "label": "size_t count", "correct": true },
            { "id": "d", "label": "int flags", "correct": false }
        ],
        "explanation": "La table des syscalls pour `sys_write` liste `size_t count` dans la colonne `rdx` (qui est arg2)."
    },
    {
        "id": "q42",
        "text": "Quel modèle de données est utilisé par Windows ?",
        "options": [
            { "id": "a", "label": "LP64", "correct": false },
            { "id": "b", "label": "LLP64", "correct": true },
            { "id": "c", "label": "ILP32", "correct": false },
            { "id": "d", "label": "Flat", "correct": false }
        ],
        "explanation": "Le texte indique 'Windows (utilise le modèle LLP64)'."
    },
    {
        "id": "q43",
        "text": "Quel modèle de données est utilisé par Linux ?",
        "options": [
            { "id": "a", "label": "LLP64", "correct": false },
            { "id": "b", "label": "LP64", "correct": true },
            { "id": "c", "label": "Win32", "correct": false },
            { "id": "d", "label": "SysV", "correct": false }
        ],
        "explanation": "Le texte indique 'Linux (utilise le modèle LP64)'."
    },
    {
        "id": "q44",
        "text": "Quelle commande GDB affiche la valeur d'un registre spécifique ?",
        "options": [
            { "id": "a", "label": "show reg <reg>", "correct": false },
            { "id": "b", "label": "i r <reg>", "correct": true },
            { "id": "c", "label": "print register <reg>", "correct": false },
            { "id": "d", "label": "view <reg>", "correct": false }
        ],
        "explanation": "La commande `i r <reg>` est notée pour 'on affiche la valeur du register'."
    },
    {
        "id": "q45",
        "text": "Quelle commande GDB affiche à chaque commande l'instruction courante ?",
        "options": [
            { "id": "a", "label": "always show $rip", "correct": false },
            { "id": "b", "label": "display $rip", "correct": false },
            { "id": "c", "label": "disp /i $rip", "correct": true },
            { "id": "d", "label": "show current", "correct": false }
        ],
        "explanation": "La commande `disp /i $rip` est décrite comme 'on affiche à chaque commande l'instruction courante'."
    },
    {
        "id": "q46",
        "text": "Comment pose-t-on un breakpoint sur une adresse spécifique dans GDB ?",
        "options": [
            { "id": "a", "label": "break <addr>", "correct": false },
            { "id": "b", "label": "bp <addr>", "correct": false },
            { "id": "c", "label": "stop at <addr>", "correct": false },
            { "id": "d", "label": "break *<addr>", "correct": true }
        ],
        "explanation": "La syntaxe donnée est `break *<addr>` (notez l'astérisque)."
    },
    {
        "id": "q47",
        "text": "Quelle commande GDB permet de lancer l'exécution du programme ?",
        "options": [
            { "id": "a", "label": "start", "correct": false },
            { "id": "b", "label": "go", "correct": false },
            { "id": "c", "label": "run", "correct": true },
            { "id": "d", "label": "exec", "correct": false }
        ],
        "explanation": "La commande `run` est indiquée pour 'on execute le programme'."
    },
    {
        "id": "q48",
        "text": "Combien d'instructions environ possède l'architecture CISC (x86-64) selon le cours ?",
        "options": [
            { "id": "a", "label": "Environ 200", "correct": false },
            { "id": "b", "label": "Plus de 1000", "correct": true },
            { "id": "c", "label": "Moins de 100", "correct": false },
            { "id": "d", "label": "500 exactement", "correct": false }
        ],
        "explanation": "Le cours mentionne pour CISC : 'possède plus de 1000 instructions'."
    },
    {
        "id": "q49",
        "text": "Quel est le registre utilisé pour arg3 (4ème argument) dans un syscall Linux (et non une fonction standard) ?",
        "options": [
            { "id": "a", "label": "rcx", "correct": false },
            { "id": "b", "label": "r10", "correct": true },
            { "id": "c", "label": "rdx", "correct": false },
            { "id": "d", "label": "r8", "correct": false }
        ],
        "explanation": "Bien que l'en-tête de colonne dise 'r', le tableau détaillé des syscalls montre que la colonne après rdx (arg3) est occupée par `r10` (note : RCX est pour les fonctions, R10 pour les syscalls)."
    },
    {
        "id": "q50",
        "text": "Dans la compilation, que signifie 'mach-O' ?",
        "options": [
            { "id": "a", "label": "Le format binaire pour Windows", "correct": false },
            { "id": "b", "label": "Le format binaire pour Linux", "correct": false },
            { "id": "c", "label": "Le format binaire pour iPhone", "correct": true },
            { "id": "d", "label": "Un type de processeur", "correct": false }
        ],
        "explanation": "Le schéma de compilation relie 'iPhone (mach-O)' au format binaire."
    }
]