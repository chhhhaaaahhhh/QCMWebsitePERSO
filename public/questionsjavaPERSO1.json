[
    {
        "id": "q1",
        "text": "Quelle est la syntaxe correcte pour déclarer et initialiser un tableau d'entiers en une seule ligne ?",
        "options": [
            {
                "id": "a",
                "label": "int[] c = new int(3);",
                "correct": false
            },
            {
                "id": "b",
                "label": "int c[] = {1, 2, 3};",
                "correct": false
            },
            {
                "id": "c",
                "label": "int[] c = [1, 2, 3];",
                "correct": false
            },
            {
                "id": "d",
                "label": "int[] c = {1, 2, 3};",
                "correct": true
            }
        ],
        "explanation": "int[] c = {1, 2, 3};"
    },
    {
        "id": "q2",
        "text": "Comment récupérer la longueur d'une chaîne de caractères (String) nommée 's' ?",
        "options": [
            {
                "id": "a",
                "label": "s.length()",
                "correct": true
            },
            {
                "id": "b",
                "label": "s.length",
                "correct": false
            },
            {
                "id": "c",
                "label": "s.size()",
                "correct": false
            },
            {
                "id": "d",
                "label": "length(s)",
                "correct": false
            }
        ],
        "explanation": "s.length()"
    },
    {
        "id": "q3",
        "text": "Selon les conventions de nommage, quelle est la classe correctement nommée ?",
        "options": [
            {
                "id": "a",
                "label": "joliChat",
                "correct": false
            },
            {
                "id": "b",
                "label": "Joli_Chat",
                "correct": false
            },
            {
                "id": "c",
                "label": "JoliChat",
                "correct": true
            },
            {
                "id": "d",
                "label": "JOLICHAT",
                "correct": false
            }
        ],
        "explanation": "JoliChat"
    },
    {
        "id": "q4",
        "text": "Selon les conventions de nommage, comment devrait s'appeler un accesseur (getter) pour un attribut booléen 'actif' ?",
        "options": [
            {
                "id": "a",
                "label": "getActif()",
                "correct": false
            },
            {
                "id": "b",
                "label": "isActif()",
                "correct": true
            },
            {
                "id": "c",
                "label": "actif()",
                "correct": false
            },
            {
                "id": "d",
                "label": "checkActif()",
                "correct": false
            }
        ],
        "explanation": "isActif()"
    },
    {
        "id": "q5",
        "text": "À quoi correspond le mot-clé 'this' ?",
        "options": [
            {
                "id": "a",
                "label": "À l'instance courante de la classe",
                "correct": true
            },
            {
                "id": "b",
                "label": "À la classe parente",
                "correct": false
            },
            {
                "id": "c",
                "label": "À une variable statique de la classe",
                "correct": false
            },
            {
                "id": "d",
                "label": "Au constructeur de la classe",
                "correct": false
            }
        ],
        "explanation": "À l'instance courante de la classe"
    },
    {
        "id": "q6",
        "text": "Où sont stockés les objets créés avec le mot-clé 'new' en mémoire ?",
        "options": [
            {
                "id": "a",
                "label": "Sur la pile (stack)",
                "correct": false
            },
            {
                "id": "b",
                "label": "Sur le tas (heap)",
                "correct": true
            },
            {
                "id": "c",
                "label": "Dans une zone mémoire statique",
                "correct": false
            },
            {
                "id": "d",
                "label": "Dans le registre du processeur",
                "correct": false
            }
        ],
        "explanation": "Sur le tas (heap)"
    },
    {
        "id": "q7",
        "text": "Que signifie le modificateur 'private' devant un attribut de classe ?",
        "options": [
            {
                "id": "a",
                "label": "L'attribut ne peut être accédé que par les classes du même package.",
                "correct": false
            },
            {
                "id": "b",
                "label": "L'attribut ne peut être modifié, mais il peut être lu de l'extérieur.",
                "correct": false
            },
            {
                "id": "c",
                "label": "L'attribut est partagé par toutes les instances de la classe.",
                "correct": false
            },
            {
                "id": "d",
                "label": "L'attribut ne peut être accédé ou modifié que depuis l'intérieur de la classe.",
                "correct": true
            }
        ],
        "explanation": "L'attribut ne peut être accédé ou modifié que depuis l'intérieur de la classe."
    },
    {
        "id": "q8",
        "text": "Quelle est la différence entre '==' et '.equals()' pour comparer deux objets String ?",
        "options": [
            {
                "id": "a",
                "label": "'.equals()' compare les adresses mémoire et '==' compare les valeurs.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Il n'y a aucune différence, ils font la même chose.",
                "correct": false
            },
            {
                "id": "c",
                "label": "'==' compare les références (adresses mémoire) et '.equals()' compare les valeurs des chaînes.",
                "correct": true
            },
            {
                "id": "d",
                "label": "'==' est utilisé pour les types primitifs et '.equals()' pour les objets, mais ils comparent tous les two la valeur.",
                "correct": false
            }
        ],
        "explanation": "'==' compare les références (adresses mémoire) et '.equals()' compare les valeurs des chaînes."
    },
    {
        "id": "q9",
        "text": "Qu'est-ce qu'une méthode 'static' NE peut PAS faire ?",
        "options": [
            {
                "id": "a",
                "label": "Accéder à des attributs d'instance (non statiques) de sa classe.",
                "correct": true
            },
            {
                "id": "b",
                "label": "Être appelée sans créer d'instance de la classe.",
                "correct": false
            },
            {
                "id": "c",
                "label": "Accéder à d'autres variables ou méthodes statiques.",
                "correct": false
            },
            {
                "id": "d",
                "label": "Prendre des paramètres et retourner une valeur.",
                "correct": false
            }
        ],
        "explanation": "Accéder à des attributs d'instance (non statiques) de sa classe."
    },
    {
        "id": "q10",
        "text": "Quelle est la caractéristique principale d'une variable 'static' (attribut statique) ?",
        "options": [
            {
                "id": "a",
                "label": "Elle ne peut pas être modifiée après son initialisation.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Elle n'est accessible que depuis les méthodes statiques.",
                "correct": false
            },
            {
                "id": "c",
                "label": "Chaque instance de la classe a sa propre copie de cette variable.",
                "correct": false
            },
            {
                "id": "d",
                "label": "Elle est partagée entre toutes les instances de la classe.",
                "correct": true
            }
        ],
        "explanation": "Elle est partagée entre toutes les instances de la classe."
    },
    {
        "id": "q11",
        "text": "Quel mot-clé est utilisé pour indiquer qu'une classe hérite d'une autre classe ?",
        "options": [
            {
                "id": "a",
                "label": "implements",
                "correct": false
            },
            {
                "id": "b",
                "label": "extends",
                "correct": true
            },
            {
                "id": "c",
                "label": "super",
                "correct": false
            },
            {
                "id": "d",
                "label": "inherits",
                "correct": false
            }
        ],
        "explanation": "extends"
    },
    {
        "id": "q12",
        "text": "Dans un constructeur de classe enfant, qu'elle est la particularité de l'appel 'super()' ?",
        "options": [
            {
                "id": "a",
                "label": "Il peut être appelé n'importe où dans le constructeur.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Il est optionnel et n'est pas nécessaire si le parent a un constructeur par défaut.",
                "correct": false
            },
            {
                "id": "c",
                "label": "Il doit être la toute première instruction du constructeur.",
                "correct": true
            },
            {
                "id": "d",
                "label": "Il est utilisé pour appeler des méthodes de la classe parent, pas le constructeur.",
                "correct": false
            }
        ],
        "explanation": "Il doit être la toute première instruction du constructeur."
    },
    {
        "id": "q13",
        "text": "Qu'est-ce que le polymorphisme permet de faire ?",
        "options": [
            {
                "id": "a",
                "label": "Stocker un objet de type parent dans une variable de type enfant.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Stocker un objet de type enfant dans une variable de type parent .",
                "correct": true
            },
            {
                "id": "c",
                "label": "Modifier le code d'une classe parente depuis une classe enfant.",
                "correct": false
            },
            {
                "id": "d",
                "label": "Empêcher une classe d'être instanciée.",
                "correct": false
            }
        ],
        "explanation": "Stocker un objet de type enfant dans une variable de type parent ."
    },
    {
        "id": "q14",
        "text": "Qu'est-ce qu'une méthode 'abstract' ?",
        "options": [
            {
                "id": "a",
                "label": "Une méthode sans corps qui doit être implémentée par les classes enfant.",
                "correct": true
            },
            {
                "id": "b",
                "label": "Une méthode qui ne peut pas être appelée de l'extérieur de la classe.",
                "correct": false
            },
            {
                "id": "c",
                "label": "Une méthode qui est partagée par toutes les instances (similaire à 'static').",
                "correct": false
            },
            {
                "id": "d",
                "label": "Une méthode finale qui ne peut pas être redéfinie (override).",
                "correct": false
            }
        ],
        "explanation": "Une méthode sans corps qui doit être implémentée par les classes enfant."
    },
    {
        "id": "q15",
        "text": "Quelle est une différence majeure entre une classe abstraite et une interface ?",
        "options": [
            {
                "id": "a",
                "label": "Une classe peut hériter de plusieurs interfaces, mais implémenter une seule classe abstraite.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Une interface ne peut contenir que des méthodes abstraites, alors qu'une classe abstraite ne peut pas.",
                "correct": false
            },
            {
                "id": "c",
                "label": "Une interface peut contenir des attributs et des constructeurs.",
                "correct": false
            },
            {
                "id": "d",
                "label": "Une classe peut implémenter plusieurs interfaces, mais ne peut hériter que d'une seule classe.",
                "correct": true
            }
        ],
        "explanation": "Une classe peut implémenter plusieurs interfaces, mais ne peut hériter que d'une seule classe."
    },
    {
        "id": "q16",
        "text": "Comment récupérer la taille d'un tableau (array) nommé 'c' ?",
        "options": [
            {
                "id": "a",
                "label": "c.size()",
                "correct": false
            },
            {
                "id": "b",
                "label": "c.length",
                "correct": true
            },
            {
                "id": "c",
                "label": "c.length()",
                "correct": false
            },
            {
                "id": "d",
                "label": "length(c)",
                "correct": false
            }
        ],
        "explanation": "c.length"
    },
    {
        "id": "q17",
        "text": "Qu'est-ce qu'une méthode 'mutateur' (setter) ?",
        "options": [
            {
                "id": "a",
                "label": "Une méthode qui permet d'obtenir la valeur d'un champ privé.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Une méthode statique qui initialise la classe.",
                "correct": false
            },
            {
                "id": "c",
                "label": "Une méthode qui permet de modifier la valeur d'un champ.",
                "correct": true
            },
            {
                "id": "d",
                "label": "Une méthode qui crée une nouvelle instance de la classe.",
                "correct": false
            }
        ],
        "explanation": "Une méthode qui permet de modifier la valeur d'un champ."
    },
    {
        "id": "q18",
        "text": "À quoi sert principalement un constructeur dans une classe Java ?",
        "options": [
            {
                "id": "a",
                "label": "À détruire l'objet pour libérer la mémoire.",
                "correct": false
            },
            {
                "id": "b",
                "label": "À initialiser les champs lors de la création d'un objet.",
                "correct": true
            },
            {
                "id": "c",
                "label": "À comparer deux objets de la même classe.",
                "correct": false
            },
            {
                "id": "d",
                "label": "À définir des méthodes statiques pour la classe.",
                "correct": false
            }
        ],
        "explanation": "À initialiser les champs lors de la création d'un objet."
    },
    {
        "id": "q19",
        "text": "Que se passe-t-il si on tente d'appeler une méthode ou d'accéder à un attribut sur une variable objet qui vaut 'null' ?",
        "options": [
            {
                "id": "a",
                "label": "Le programme continue en ignorant l'instruction.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Une erreur de compilation est générée.",
                "correct": false
            },
            {
                "id": "c",
                "label": "Une 'NullPointerException' est levée à l'exécution.",
                "correct": true
            },
            {
                "id": "d",
                "label": "L'objet est automatiquement initialisé avec des valeurs par défaut.",
                "correct": false
            }
        ],
        "explanation": "Une 'NullPointerException' est levée à l'exécution."
    },
    {
        "id": "q20",
        "text": "Dans l'exemple de la fonction 'factorielle' du cours, quelle technique de programmation est utilisée ?",
        "options": [
            {
                "id": "a",
                "label": "La récursion",
                "correct": true
            },
            {
                "id": "b",
                "label": "L'itération (boucle while)",
                "correct": false
            },
            {
                "id": "c",
                "label": "Le polymorphisme",
                "correct": false
            },
            {
                "id": "d",
                "label": "La généricité",
                "correct": false
            }
        ],
        "explanation": "La récursion"
    },
    {
        "id": "q21",
        "text": "Quel niveau de visibilité permet à un élément d'être accessible par la classe, le package et les sous-classes, mais pas par 'tout' le monde ?",
        "options": [
            {
                "id": "a",
                "label": "public",
                "correct": false
            },
            {
                "id": "b",
                "label": "private",
                "correct": false
            },
            {
                "id": "c",
                "label": "Visibilité par défaut (aucun mot-clé)",
                "correct": false
            },
            {
                "id": "d",
                "label": "protected",
                "correct": true
            }
        ],
        "explanation": "protected"
    },
    {
        "id": "q22",
        "text": "Comment une classe enfant peut-elle appeler explicitement une méthode (non-constructeur) de sa classe parent ?",
        "options": [
            {
                "id": "a",
                "label": "En utilisant 'this.methode()'",
                "correct": false
            },
            {
                "id": "b",
                "label": "En utilisant 'super.methode()'",
                "correct": true
            },
            {
                "id": "c",
                "label": "En utilisant 'parent.methode()'",
                "correct": false
            },
            {
                "id": "d",
                "label": "Ce n'est pas possible, la méthode enfant remplace toujours la parent.",
                "correct": false
            }
        ],
        "explanation": "En utilisant 'super.methode()'"
    },
    {
        "id": "q23",
        "text": "Quelle annotation est utilisée pour indiquer qu'une classe enfant redéfinit une méthode de sa classe parent ?",
        "options": [
            {
                "id": "a",
                "label": "@Override",
                "correct": true
            },
            {
                "id": "b",
                "label": "@Redefine",
                "correct": false
            },
            {
                "id": "c",
                "label": "@Inherit",
                "correct": false
            },
            {
                "id": "d",
                "label": "@Super",
                "correct": false
            }
        ],
        "explanation": "@Override"
    },
    {
        "id": "q24",
        "text": "Quel mot-clé est utilisé pour qu'une classe applique un 'contrat' défini par une interface ?",
        "options": [
            {
                "id": "a",
                "label": "extends",
                "correct": false
            },
            {
                "id": "b",
                "label": "inherits",
                "correct": false
            },
            {
                "id": "c",
                "label": "implements",
                "correct": true
            },
            {
                "id": "d",
                "label": "uses",
                "correct": false
            }
        ],
        "explanation": "implements"
    },
    {
        "id": "q25",
        "text": "Dans le contexte des classes 'sealed' (scellées), que fait le mot-clé 'permits' ?",
        "options": [
            {
                "id": "a",
                "label": "Il empêche toute classe d'hériter.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Il donne la liste des classes autorisées à hériter ou implémenter.",
                "correct": true
            },
            {
                "id": "c",
                "label": "Il permet à la classe d'implémenter plusieurs interfaces.",
                "correct": false
            },
            {
                "id": "d",
                "label": "Il rend tous les attributs de la classe 'public'.",
                "correct": false
            }
        ],
        "explanation": "Il donne la liste des classes autorisées à hériter ou implémenter."
    },
    {
        "id": "q26",
        "text": "Si une classe enfant est déclarée 'public final class...', qu'est-ce que cela signifie ?",
        "options": [
            {
                "id": "a",
                "label": "La classe ne peut pas être instanciée.",
                "correct": false
            },
            {
                "id": "b",
                "label": "La classe est la version finale du projet.",
                "correct": false
            },
            {
                "id": "c",
                "label": "N'importe quelle autre classe peut hériter de celle-ci.",
                "correct": false
            },
            {
                "id": "d",
                "label": "Aucune autre classe ne peut hériter de cette classe.",
                "correct": true
            }
        ],
        "explanation": "Aucune autre classe ne peut hériter de cette classe."
    },
    {
        "id": "q27",
        "text": "Quel est l'objectif principal d'une 'enum' (énumération) en Java ?",
        "options": [
            {
                "id": "a",
                "label": "Définir un ensemble fini et fixe de constantes nommées.",
                "correct": true
            },
            {
                "id": "b",
                "label": "Stocker des données de manière générique, comme une 'Cellule&ltT&gt'.",
                "correct": false
            },
            {
                "id": "c",
                "label": "Créer des classes dont on ne peut pas hériter.",
                "correct": false
            },
            {
                "id": "d",
                "label": "Remplacer les classes abstraites.",
                "correct": false
            }
        ],
        "explanation": "Définir un ensemble fini et fixe de constantes nommées."
    },
    {
        "id": "q28",
        "text": "Une 'enum' peut-elle avoir des attributs, un constructeur et des méthodes ?",
        "options": [
            {
                "id": "a",
                "label": "Non, une enum ne peut contenir que la liste des constantes.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Oui, une enum est une classe spéciale et peut avoir des attributs, un constructeur et des méthodes.",
                "correct": true
            },
            {
                "id": "c",
                "label": "Seulement des attributs 'static final', mais pas de constructeur.",
                "correct": false
            },
            {
                "id": "d",
                "label": "Seulement des méthodes, mais pas d'attributs ni de constructeur.",
                "correct": false
            }
        ],
        "explanation": "Oui, une enum est une classe spéciale et peut avoir des attributs, un constructeur et des méthodes."
    },
    {
        "id": "q29",
        "text": "À quoi sert la syntaxe '&ltT&gt' (généricité) dans la définition 'class Cellule&ltT&gt' ?",
        "options": [
            {
                "id": "a",
                "label": "À indiquer que la classe est statique.",
                "correct": false
            },
            {
                "id": "b",
                "label": "À définir un type 'placeholder' qui sera spécifié lors de l'utilisation de la classe.",
                "correct": true
            },
            {
                "id": "c",
                "label": "À marquer la classe comme étant un 'Template'.",
                "correct": false
            },
            {
                "id": "d",
                "label": "À limiter l'héritage de la classe.",
                "correct": false
            }
        ],
        "explanation": "À définir un type 'placeholder' qui sera spécifié lors de l'utilisation de la classe."
    },
    {
        "id": "q30",
        "text": "Quelle est la syntaxe correcte pour parcourir tous les éléments d'un tableau 'int[] c' ?",
        "options": [
            {
                "id": "a",
                "label": "for (int i = 0; i < c.length; i++) { ... }",
                "correct": true
            },
            {
                "id": "b",
                "label": "for (int i = 0; i < c.length(); i++) { ... }",
                "correct": false
            },
            {
                "id": "c",
                "label": "for (int i : c.length()) { ... }",
                "correct": false
            },
            {
                "id": "d",
                "label": "foreach (int i in c) { ... }",
                "correct": false
            }
        ],
        "explanation": "for (int i = 0; i < c.length; i++) { ... }"
    },
    {
        "id": "q31",
        "text": "Si 'Chat' hérite de 'Animal', et qu'on exécute : 'Animal a = new Chat(...);'. Quelles méthodes l'instance 'a' peut-elle appeler directement ?",
        "explanation": "Seulement les méthodes définies dans la classe Animal (ou héritées par Animal).",
        "options": [
            {
                "id": "a",
                "label": "Toutes les méthodes de 'Animal' ET toutes celles de 'Chat'.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Seulement les méthodes définies dans la classe Animal (ou héritées par Animal).",
                "correct": true
            },
            {
                "id": "c",
                "label": "Seulement les méthodes de 'Chat', car l'objet réel est un 'Chat'.",
                "correct": false
            },
            {
                "id": "d",
                "label": "Aucune, il faut 'caster' 'a' en 'Chat' d'abord.",
                "correct": false
            }
        ]
    },
    {
        "id": "q32",
        "text": "Que se passe-t-il si on essaie d'instancier une classe déclarée 'public abstract class Animal' ?",
        "explanation": "Le compilateur lève une erreur car la classe est abstraite.",
        "options": [
            {
                "id": "a",
                "label": "Un objet 'Animal' est créé avec des valeurs 'null' pour ses attributs.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Cela fonctionne uniquement si la classe abstraite n'a pas de méthodes abstraites.",
                "correct": false
            },
            {
                "id": "c",
                "label": "Le compilateur lève une erreur car la classe est abstraite.",
                "correct": true
            },
            {
                "id": "d",
                "label": "Une 'AbstractMethodException' est levée à l'exécution.",
                "correct": false
            }
        ]
    },
    {
        "id": "q33",
        "text": "Quelle est la principale contrainte d'une méthode 'static' (méthode de classe) ?",
        "explanation": "Elle ne peut pas accéder à des membres d'instance (non statiques) comme 'this'.",
        "options": [
            {
                "id": "a",
                "label": "Elle ne peut pas être appelée depuis l'extérieur de la classe.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Elle ne peut pas avoir de paramètres.",
                "correct": false
            },
            {
                "id": "c",
                "label": "Elle doit obligatoirement retourner une valeur.",
                "correct": false
            },
            {
                "id": "d",
                "label": "Elle ne peut pas accéder à des membres d'instance (non statiques) comme 'this'.",
                "correct": true
            }
        ]
    },
    {
        "id": "q34",
        "text": "Dans le constructeur d'une classe enfant, quelle est la règle impérative concernant l'appel 'super(...)' ?",
        "explanation": "Il doit s'agir de la toute première instruction du constructeur.",
        "options": [
            {
                "id": "a",
                "label": "Il doit s'agir de la toute première instruction du constructeur.",
                "correct": true
            },
            {
                "id": "b",
                "label": "Il doit être appelé après l'initialisation des attributs de l'enfant.",
                "correct": false
            },
            {
                "id": "c",
                "label": "Il est optionnel si la classe parent a un constructeur.",
                "correct": false
            },
            {
                "id": "d",
                "label": "Il doit être la dernière instruction du constructeur.",
                "correct": false
            }
        ]
    },
    {
        "id": "q35",
        "text": "Pourquoi 'String s1 = \"txt\"; String s2 = \"txt\";' donne-t-il 'true' pour 's1 == s2' ?",
        "explanation": "Par optimisation, Java crée une seule instance de la chaîne 'txt' dans le 'String pool'.",
        "options": [
            {
                "id": "a",
                "label": "Car '.equals()' est appelé implicitement par '=='.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Par optimisation, Java crée une seule instance de la chaîne 'txt' dans le 'String pool'.",
                "correct": true
            },
            {
                "id": "c",
                "label": "'==' compare toujours la valeur des chaînes, pas la référence.",
                "correct": false
            },
            {
                "id": "d",
                "label": "C'est un cas particulier qui ne fonctionne que pour la chaîne 'txt'.",
                "correct": false
            }
        ]
    },
    {
        "id": "q36",
        "text": "Si 'String s3 = \"5\";' et 'int i1 = 5;', que retourne 's3.equals(i1)' ?",
        "explanation": "False, car 'equals' compare le type et la valeur, et 'i1' n'est pas un 'String'.",
        "options": [
            {
                "id": "a",
                "label": "True, car Java convertit 'i1' en 'String' avant la comparaison.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Une erreur de compilation car on ne peut pas comparer un 'String' et un 'int'.",
                "correct": false
            },
            {
                "id": "c",
                "label": "False, car 'equals' compare le type et la valeur, et 'i1' n'est pas un 'String'.",
                "correct": true
            },
            {
                "id": "d",
                "label": "Une 'ClassCastException' à l'exécution.",
                "correct": false
            }
        ]
    },
    {
        "id": "q37",
        "text": "Quel modificateur rend un élément accessible uniquement dans sa classe et son package ?",
        "explanation": "Le modificateur par défaut (aucun mot-clé).",
        "options": [
            {
                "id": "a",
                "label": "private",
                "correct": false
            },
            {
                "id": "b",
                "label": "public",
                "correct": false
            },
            {
                "id": "c",
                "label": "protected",
                "correct": false
            },
            {
                "id": "d",
                "label": "Le modificateur par défaut (aucun mot-clé).",
                "correct": true
            }
        ]
    },
    {
        "id": "q38",
        "text": "À quoi sert la généricité (ex: 'class Cellule&ltT&gt') ?",
        "explanation": "À créer une classe qui peut fonctionner avec différents types d'objets (placeholder).",
        "options": [
            {
                "id": "a",
                "label": "À créer une classe qui ne peut être instanciée qu'une seule fois.",
                "correct": false
            },
            {
                "id": "b",
                "label": "À forcer la classe à être 'public'.",
                "correct": false
            },
            {
                "id": "c",
                "label": "À créer une classe qui peut fonctionner avec différents types d'objets (placeholder).",
                "correct": true
            },
            {
                "id": "d",
                "label": "À marquer la classe comme étant un 'Test'.",
                "correct": false
            }
        ]
    },
    {
        "id": "q39",
        "text": "Que signifie 'public sealed interface Animal permits Chien, Chat' ?",
        "explanation": "Que seule les classes 'Chien' et 'Chat' sont autorisées à implémenter 'Animal'.",
        "options": [
            {
                "id": "a",
                "label": "Que 'Animal' ne peut être utilisée que par les classes 'Chien' et 'Chat'.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Que seule les classes 'Chien' et 'Chat' sont autorisées à implémenter 'Animal'.",
                "correct": true
            },
            {
                "id": "c",
                "label": "Que 'Animal' hérite de 'Chien' et 'Chat'.",
                "correct": false
            },
            {
                "id": "d",
                "label": "Que l'interface est verrouillée et ne peut plus être modifiée.",
                "correct": false
            }
        ]
    },
    {
        "id": "q40",
        "text": "Si une classe 'Chat' est déclarée 'public non-sealed class Chat... ' (héritant d'une classe scellée), qu'est-ce que cela implique ?",
        "explanation": "Que n'importe quelle autre classe peut désormais hériter de 'Chat'.",
        "options": [
            {
                "id": "a",
                "label": "Que 'Chat' ne peut plus hériter de personne.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Que 'Chat' ne peut pas être instanciée.",
                "correct": false
            },
            {
                "id": "c",
                "label": "Que n'importe quelle autre classe peut désormais hériter de 'Chat'.",
                "correct": true
            },
            {
                "id": "d",
                "label": "Que 'Chat' est obligée d'implémenter une interface.",
                "correct": false
            }
        ]
    },
    {
        "id": "q41",
        "text": "Techniquement, qu'est-ce que 'LUNDI' dans 'public enum Jour { LUNDI, MARDI... }' ?",
        "explanation": "Une instance 'public static final' de la classe 'Jour'.",
        "options": [
            {
                "id": "a",
                "label": "Une simple variable 'String' statique.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Une variable 'int' globale.",
                "correct": false
            },
            {
                "id": "c",
                "label": "Une instance 'public static final' de la classe 'Jour'.",
                "correct": true
            },
            {
                "id": "d",
                "label": "Une méthode statique qui retourne un 'Jour'.",
                "correct": false
            }
        ]
    },
    {
        "id": "q42",
        "text": "Quelle est la principale différence conceptuelle entre 'Classe abstraite' et 'Interface' ?",
        "explanation": "La classe abstraite définit ce qu'un objet 'est', l'interface définit ce qu'il 'sait faire'.",
        "options": [
            {
                "id": "a",
                "label": "Les interfaces ne peuvent pas avoir de méthodes, seulement des attributs.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Les classes abstraites ne peuvent pas avoir de constructeur.",
                "correct": false
            },
            {
                "id": "c",
                "label": "La classe abstraite définit ce qu'un objet 'est', l'interface définit ce qu'il 'sait faire'.",
                "correct": true
            },
            {
                "id": "d",
                "label": "On ne peut hériter que d'une interface, mais implémenter plusieurs classes abstraites.",
                "correct": false
            }
        ]
    },
    {
        "id": "q43",
        "text": "Si 'Chat c1 = new Chat(10, \"Oupi\");', où est stockée la référence 'c1' et où est stocké l'objet 'Chat' ?",
        "explanation": "La référence 'c1' est sur la pile, l'objet 'Chat' créé avec 'new' est sur le tas.",
        "options": [
            {
                "id": "a",
                "label": "Les deux sont stockés sur le tas.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Les deux sont stockés sur la pile.",
                "correct": false
            },
            {
                "id": "c",
                "label": "La référence 'c1' est sur le tas, l'objet 'Chat' est sur la pile.",
                "correct": false
            },
            {
                "id": "d",
                "label": "La référence 'c1' est sur la pile, l'objet 'Chat' créé avec 'new' est sur le tas.",
                "correct": true
            }
        ]
    },
    {
        "id": "q44",
        "text": "Qu'est-il impossible de faire avec une variable de type 'null' ?",
        "explanation": "Accéder à ses attributs ou appeler ses méthodes (non statiques).",
        "options": [
            {
                "id": "a",
                "label": "La comparer avec '==' à une autre variable.",
                "correct": false
            },
            {
                "id": "b",
                "label": "L'assigner à une variable de type 'Object'.",
                "correct": false
            },
            {
                "id": "c",
                "label": "Accéder à ses attributs ou appeler ses méthodes (non statiques).",
                "correct": true
            },
            {
                "id": "d",
                "label": "La passer en paramètre d'une méthode.",
                "correct": false
            }
        ]
    },
    {
        "id": "q45",
        "text": "Une classe 'public abstract class Forme implements Dessinable' est déclarée. Doit-elle implémenter les méthodes de 'Dessinable' ?",
        "explanation": "Non, elle peut choisir de ne pas les implémenter (laissant les sous-classes le faire).",
        "options": [
            {
                "id": "a",
                "label": "Oui, toute classe qui 'implements' une interface doit implémenter toutes ses méthodes.",
                "correct": false
            },
            {
                "id": "b",
                "label": "Non, car une classe abstraite ne peut pas implémenter d'interface.",
                "correct": false
            },
            {
                "id": "c",
                "label": "Non, elle peut choisir de ne pas les implémenter (laissant les sous-classes le faire).",
                "correct": true
            },
            {
                "id": "d",
                "label": "Oui, mais seulement si 'Dessinable' est aussi 'abstract'.",
                "correct": false
            }
        ]
    },
    {
        "id": "q46",
        "text": "Que signifie le modificateur 'protected' sur un attribut ?",
        "explanation": "Il est accessible par la classe, le package, et les sous-classes (même hors package).",
        "options": [
            {
                "id": "a",
                "label": "Il est accessible uniquement par la classe et ses sous-classes (pas le package).",
                "correct": false
            },
            {
                "id": "b",
                "label": "Il est accessible par la classe, le package, et les sous-classes (même hors package).",
                "correct": true
            },
            {
                "id": "c",
                "label": "Il est synonyme de 'private', mais pour l'héritage.",
                "correct": false
            },
            {
                "id": "d",
                "label": "Il n'est accessible que par le package.",
                "correct": false
            }
        ]
    }
]